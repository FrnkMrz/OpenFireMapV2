<!-- 
    =============================================================================
    PROJEKT: OpenFireMap V2 - Lernversion (Refactored)
    AUTOR: Gemini (im Auftrag von Frank März)
    DATUM: 2026-01-21 (Final: Mit Debounce & Wartestatus)
    =============================================================================
    
    PROJEKT-BESCHREIBUNG & LERNZIELE:
    
    Dies ist ein persönliches Lernprojekt, um die Entwicklung moderner Webanwendungen
    (Single Page Applications) zu verstehen und anzuwenden.
    
    WAS MACHT DIESE WEBSEITE?
    Dieses Tool dient der Visualisierung von rettungsdienstlich relevanter Infrastruktur
    aus der OpenStreetMap-Datenbank.
    
    Kernfunktionen:
    1. Interaktive Karte: Zeigt Feuerwachen, Hydranten, Wassertanks und Defibrillatoren (AED).
    2. Intelligenter Zoom: 
       - Wachen erscheinen ab Zoom 12.
       - Hydranten ab Zoom 15.
       - Defibrillatoren als Punkte ab Zoom 15, als detaillierte Icons ab Zoom 17.
    3. Einsatztaktik: Klick auf einen Hydranten zeigt einen 100m-Radius (Schlauchstrecke).
    4. Export-Tools:
       - PNG-Export: Erstellt hochauflösende, druckfertige Karten mit Rahmen, Titel,
         Datum, Maßstab und Lizenzhinweisen.
       - GPX-Export: Exportiert die sichtbaren Punkte für Navigationsgeräte.
    5. Internationalisierung: Die Oberfläche passt sich automatisch der Browsersprache an
       (unterstützt DE, EN, FR, ES, IT, PL, NL, CS, DA, FI, SV, NO, PT, FL, LB, JA, KO, MS, TH, ZH, YUE, TW).
    6. Smart UX (NEU): 
       - Menüs schließen automatisch nach 10 Sekunden Inaktivität.
       - Debounce: Daten werden erst 200ms nach Ende der Bewegung geladen.
       
    TECHNISCHER AUFBAU (REFACTORED):
    Die Anwendung wurde in zwei Dateien aufgeteilt, um die Übersichtlichkeit zu verbessern:
    
    1. index.html (Diese Datei):
       - Enthält die HTML-Struktur, CSS-Design und die JavaScript-Logik.
       - Lädt die externen Bibliotheken (Leaflet, Tailwind).
       
    2. translations.js (Externe Datei):
       - Enthält das gesamte Wörterbuch (Dictionary) für alle Sprachen.
       - Wird im <head> geladen und stellt die Variable 'translations' bereit.

    RECHTLICHE HINWEISE:
    Impressum und Datenschutzerklärung sind fest integriert ("Info & Recht"-Button),
    um einen rechtssicheren Betrieb zu ermöglichen.
-->

<!DOCTYPE html>
<!-- 'lang="de"' sagt dem Browser: "Diese Seite spricht Deutsch." -->
<html lang="de">
<head>
    <!-- TECHNISCHE GRUNDEINSTELLUNGEN -->
    <meta charset="UTF-8">
    <!-- Wichtig für Handys: "Pass den Inhalt an die Bildschirmbreite an!" -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenFireMap.org</title>
    
    <!-- 
        PERFORMANCE (Preconnect):
        Wir "warnen" den Browser vor, dass wir gleich Daten von diesen Servern brauchen.
        So kann er schon mal den DNS-Eintrag suchen und die Verbindung öffnen.
    -->
    <link rel="preconnect" href="https://unpkg.com"> <!-- Für Leaflet -->
    <link rel="preconnect" href="https://cdn.tailwindcss.com"> <!-- Für CSS -->
    <link rel="preconnect" href="https://a.basemaps.cartocdn.com"> <!-- Für Kartenbilder -->
    <link rel="preconnect" href="https://overpass-api.de"> <!-- Für Daten -->

    <!-- 
        FAVICONS & APP ICONS (ANGEPASST)
        Diese Icons sorgen dafür, dass die Seite als Lesezeichen oder App auf dem Homescreen gut aussieht.
    -->
    <link rel="apple-touch-icon" sizes="57x57" href="favicons/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="favicons/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="favicons/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="favicons/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="favicons/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="favicons/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="favicons/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="favicons/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="favicons/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192"  href="favicons/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="favicons/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicons/favicon-16x16.png">
    
    <link rel="manifest" href="favicons/sitemanifest">
    
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="favicon/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
    
    <link rel="icon" type="image/x-icon" href="favicons/favicon.ico">
    
    <!-- 
        EXTERNE WERKZEUGE (BIBLIOTHEKEN) 
        Wir laden fertige Code-Pakete aus dem Internet.
    -->
    
    <!-- Leaflet CSS: Das Design für die Karte -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <!-- Leaflet JS: Die Logik für die Karte (jetzt mit defer) -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer></script>
    
    <!-- Tailwind CSS: Ein Design-Werkzeugkasten für schnelle Styles (jetzt mit defer) -->
    <script src="https://cdn.tailwindcss.com" defer></script>

    <!-- 
        LOKALE RESSOURCEN (HINZUGEFÜGT)
        Hier laden wir unsere ausgelagerte Sprachdatei. 
    -->
    <script src="translations.js"></script>

    <!-- HIER BEGINNT DAS DESIGN (CSS) -->
    <style>
        /* Grundeinstellungen */
        body { 
            margin: 0; padding: 0; 
            overflow: hidden; /* Keine Scrollbalken */
            font-family: sans-serif; 
            background: #0f172a; /* Dunkelblau */
        }
        
        /* Der Container für die Karte */
        #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #1e293b; }
        
        /* Glassmorphismus (Milchglas-Effekt) */
        .glass-panel { 
            background: rgba(15, 23, 42, 0.90); 
            backdrop-filter: blur(12px); 
            border: 1px solid rgba(255, 255, 255, 0.1); 
        }
        
        /* Layout für das Info-Fenster */
        #legal-modal {
            display: none; 
            flex-direction: column; 
        }

        /* Animation für Marker */
        .icon-container { 
            display: flex; align-items: center; justify-content: center; 
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4)); 
            transition: transform 0.1s ease; 
        }
        .icon-container:hover { transform: scale(1.15); z-index: 1000 !important; }

        /* Farbige Punkte für Zoomstufen < 17 */
        .hydrant-dot { background-color: #ef4444; border: 1.5px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        .tank-dot { background-color: #3b82f6; border: 1.5px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        .defib-dot { background-color: #16a34a; border: 1.5px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        .station-square { background-color: #ef4444; border: 1px solid white; width: 10px; height: 10px; box-shadow: 0 0 4px rgba(0,0,0,0.5); }

        /* Tooltips (Info-Schildchen) */
        .leaflet-tooltip { 
            background: #0f172a; color: white; border: 1px solid rgba(255,255,255,0.15); 
            border-radius: 8px; font-size: 12px; box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6); padding: 0; 
        }

        /* Text "100m" am Kreis */
        .range-label {
            background: transparent !important; border: none !important; box-shadow: none !important;
            color: #333333 !important; font-weight: bold; font-size: 14px;
            text-shadow: -1px -1px 0 rgba(255,255,255,0.8), 1px -1px 0 rgba(255,255,255,0.8), -1px 1px 0 rgba(255,255,255,0.8), 1px 1px 0 rgba(255,255,255,0.8);
        }
        
        .layer-btn.active { color: #3b82f6; background: rgba(59, 130, 246, 0.1); font-weight: bold; }
        
        /* Pulsierende Animation */
        @keyframes pulse-red { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .exporting-active { animation: pulse-red 2s infinite; }

        /* Rote Fehlermeldung */
        #notification-box { 
            position: absolute; top: 20px; right: 20px; z-index: 2000; display: none;
            background: #ef4444; color: white; padding: 12px 24px; border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3); font-weight: 600;
        }

        .selection-mode { cursor: crosshair !important; }
        .zoom-btn:disabled { opacity: 0.3; cursor: not-allowed; border-color: transparent; }
        
        /* Links */
        a { color: #3b82f6; text-decoration: none; }
        a:hover { text-decoration: underline; }
        
        /* Scrollbar Design */
        .custom-scroll::-webkit-scrollbar { width: 4px; }
        .custom-scroll::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        .custom-scroll::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }
    </style>
</head>
<body>

<!-- HTML STRUKTUR -->

<h1 class="sr-only">OpenFireMap - Interaktive Karte für Feuerwehr-Infrastruktur</h1>

<div id="map" aria-label="Interaktive Karte" role="application"></div>

<!-- Live Region für Meldungen -->
<div id="notification-box" role="alert" aria-live="polite"></div>

<!-- STEUERLEISTE (Oben Links) -->
<div class="absolute top-5 left-5 z-[1000] flex gap-3">
    <!-- Suche -->
    <div class="flex glass-panel rounded-2xl shadow-2xl p-1 border border-white/5 focus-within:ring-2 focus-within:ring-blue-500">
        <label for="search-input" class="sr-only" data-i18n="search_placeholder">Ort suchen</label>
        <input type="text" id="search-input" data-i18n-placeholder="search_placeholder" placeholder="Ort suchen..." class="bg-transparent px-4 py-2 text-sm text-white outline-none focus:ring-0 w-48 focus:w-72 transition-all duration-500 placeholder:text-slate-400">
        
        <button onclick="searchLocation()" aria-label="Suchen" class="p-2 text-slate-400 hover:text-white transition-colors focus:outline-none focus:text-white rounded-xl">
            <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
        </button>
    </div>
    
    <!-- GPS -->
    <button onclick="locateUser()" id="locate-btn" data-i18n-title="locate_title" aria-label="Meinen Standort bestimmen" class="glass-panel p-3 rounded-2xl text-slate-400 hover:text-emerald-400 shadow-2xl transition-all border border-white/10 active:scale-95 focus:outline-none focus:ring-2 focus:ring-emerald-500" title="Mein Standort">
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
    </button>
    
    <!-- Layer -->
    <button onclick="toggleLayerMenu()" id="layer-btn-trigger" aria-haspopup="true" aria-expanded="false" aria-controls="layer-menu" aria-label="Kartenhintergrund wechseln" data-i18n-title="layers_title" class="glass-panel p-3 rounded-2xl text-slate-400 hover:text-white shadow-2xl transition-all border border-white/10 active:scale-95 focus:outline-none focus:ring-2 focus:ring-blue-500" title="Karte wechseln">
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
        </svg>
    </button>

    <!-- Export -->
    <button onclick="toggleExportMenu()" id="export-btn-trigger" aria-haspopup="true" aria-expanded="false" aria-controls="export-menu" aria-label="Export Menü öffnen" data-i18n-title="export_title" class="glass-panel p-3 rounded-2xl text-blue-400 hover:text-blue-300 shadow-2xl transition-all border border-blue-500/20 active:scale-95 focus:outline-none focus:ring-2 focus:ring-blue-500" title="Export">
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
    </button>
</div>

<!-- INFO & RECHT KNOPF (Klein, Unten Links) -->
<div class="absolute bottom-8 left-5 z-[1000]">
    <button onclick="toggleLegalModal()" id="btn-legal-trigger" aria-haspopup="true" aria-expanded="false" aria-controls="legal-modal" class="glass-panel p-1.5 rounded-xl text-slate-400 hover:text-white shadow-xl transition-all border border-white/10 active:scale-95 flex items-center gap-1.5 focus:outline-none focus:ring-2 focus:ring-blue-500">
        <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
        <span class="text-[10px] font-bold hidden md:inline" data-i18n="legal_btn">Info & Recht</span>
    </button>
</div>

<!-- INFO-BOX (Impressum & Recht) -->
<div id="legal-modal" role="dialog" aria-modal="true" aria-labelledby="legal-title" class="hidden absolute bottom-20 left-5 z-[2000] w-80 glass-panel rounded-3xl p-5 text-slate-300 shadow-2xl border border-white/10 max-h-[60vh] flex flex-col">
    <div class="flex justify-between items-center mb-4 border-b border-white/10 pb-3 shrink-0">
        <h2 id="legal-title" class="text-lg font-bold text-white flex items-center gap-2">
            <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-blue-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
            Rechtliches
        </h2>
        <button onclick="toggleLegalModal()" aria-label="Schließen" class="text-slate-400 hover:text-white transition-colors focus:outline-none focus:text-white rounded-lg p-1">
            <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
        </button>
    </div>
    
    <div class="overflow-y-auto custom-scroll pr-2 text-xs space-y-6">
        <!-- Impressum -->
        <section>
            <h3 class="text-sm font-bold text-white mb-1">Impressum</h3>
            <p class="leading-relaxed text-slate-400">
                Angaben gemäß § 5 TMG:<br><br>
                <strong>Frank März</strong><br>
                Kersbacher Weg 3<br>
                91220 Schnaittach<br>
                Deutschland<br><br>
                Kontakt:<br>
                Telefon: +499153/9229501<br>
                E-Mail: info@openfiremap.org
            </p>
        </section>
        
        <!-- Datenschutz -->
        <section>
            <h3 class="text-sm font-bold text-white mb-1">Datenschutzerklärung (Kurzfassung)</h3>
            <p class="leading-relaxed text-slate-400 mb-2">
                Diese Anwendung läuft als "Client-Side Application" direkt in Ihrem Browser. Wir speichern keine personenbezogenen Daten auf eigenen Servern.
            </p>
            <p class="leading-relaxed text-slate-400">
                Um die Karten anzuzeigen und Daten abzurufen, verbindet sich Ihr Browser jedoch direkt mit folgenden externen Diensten, wobei technisch bedingt Ihre IP-Adresse übertragen wird:
            </p>
            <ul class="list-disc list-inside mt-2 space-y-1 text-slate-500">
                <li><strong>Karten-Server (OSM, CartoDB, Esri/ArcGIS, OpenTopoMap):</strong> Zum Laden der Kartenbilder (Kacheln).</li>
                <li><strong>Overpass API:</strong> Zum Abruf der Hydranten-, Wachen- und Defibrillatordaten.</li>
                <li><strong>Nominatim (OSM):</strong> Für die Ortssuche und Adressbestimmung.</li>
            </ul>
        </section>
        
        <!-- Lizenzen -->
        <section>
            <h3 class="text-sm font-bold text-white mb-1">Quellen & Lizenzen</h3>
            <ul class="list-disc list-inside space-y-1 text-slate-400">
                <li>
                    <strong>Kartendaten:</strong> &copy; <a href="https://www.openstreetmap.org/copyright" target="_blank" class="focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">OpenStreetMap</a>-Mitwirkende (ODbL).
                </li>
                <li>
                    <strong>Kartenstil (Standard/Dark/Hell):</strong> &copy; <a href="https://carto.com/attributions" target="_blank" class="focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">CARTO</a>.
                </li>
                <li>
                    <strong>Satellitenbilder:</strong> Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community.
                </li>
                <li>
                    <strong>Topographische Karte:</strong> Daten &copy; OpenStreetMap-Mitwirkende, SRTM | Darstellung &copy; <a href="http://opentopomap.org" target="_blank" class="focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">OpenTopoMap</a> (CC-BY-SA).
                </li>
                <li>
                    <strong>Software-Bibliotheken:</strong> <a href="https://leafletjs.com/" target="_blank" class="focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">Leaflet</a>, <a href="https://tailwindcss.com/" target="_blank" class="focus:outline-none focus:ring-2 focus:ring-blue-500 rounded-sm">Tailwind CSS</a>.
                </li>
            </ul>
        </section>

        <!-- Haftung -->
        <section class="border-t border-white/5 pt-2">
            <h3 class="text-sm font-bold text-white mb-1">Rechtlicher Hinweis & Kontakt</h3>
            <p class="leading-relaxed text-slate-400 mb-2">
                Dies ist ein rein privates, nicht-kommerzielles Projekt ohne Gewinnerzielungsabsicht.
            </p>
            <p class="leading-relaxed text-amber-500/80 italic mb-2 font-semibold">
                "Keine Abmahnung ohne vorherigen Kontakt"
            </p>
            <p class="leading-relaxed text-slate-500">
                Sollte der Inhalt oder die Aufmachung dieser Seiten fremde Rechte Dritter oder gesetzliche Bestimmungen verletzen, so bitte ich um eine entsprechende Nachricht ohne Kostennote. Ich garantiere, dass die zu Recht beanstandeten Passagen unverzüglich entfernt werden, ohne dass von Ihrer Seite die Einschaltung eines Rechtsbeistandes erforderlich ist.
            </p>
        </section>
    </div>
</div>

<!-- MENÜ FÜR KARTEN-HINTERGRÜNDE -->
<div id="layer-menu" role="menu" aria-labelledby="layer-btn-trigger" class="hidden absolute top-20 left-28 z-[1001] w-64 glass-panel rounded-2xl p-4 shadow-2xl text-white border border-white/10">
    <h3 class="text-xs font-bold uppercase tracking-wider text-slate-500 mb-3 text-center" data-i18n="bg_header">Hintergrund</h3>
    <div class="grid grid-cols-1 gap-1">
        <button onclick="setBaseLayer('voyager')" role="menuitem" id="btn-voyager" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2 focus:outline-none focus:ring-2 focus:ring-blue-500"><div class="w-3 h-3 rounded-full bg-blue-500" aria-hidden="true"></div> <span data-i18n="layer_std">Standard (Voyager)</span></button>
        <button onclick="setBaseLayer('positron')" role="menuitem" id="btn-positron" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2 focus:outline-none focus:ring-2 focus:ring-blue-500"><div class="w-3 h-3 rounded-full bg-slate-300" aria-hidden="true"></div> <span data-i18n="layer_print">Druck (Hell)</span></button>
        <button onclick="setBaseLayer('dark')" role="menuitem" id="btn-dark" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2 focus:outline-none focus:ring-2 focus:ring-blue-500"><div class="w-3 h-3 rounded-full bg-slate-800" aria-hidden="true"></div> <span data-i18n="layer_night">Nacht (Dunkel)</span></button>
        <button onclick="setBaseLayer('satellite')" role="menuitem" id="btn-satellite" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2 focus:outline-none focus:ring-2 focus:ring-blue-500"><div class="w-3 h-3 rounded-full bg-green-600" aria-hidden="true"></div> <span data-i18n="layer_sat">Satellit (Esri)</span></button>
        <button onclick="setBaseLayer('topo')" role="menuitem" id="btn-topo" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2 focus:outline-none focus:ring-2 focus:ring-blue-500"><div class="w-3 h-3 rounded-full bg-amber-600" aria-hidden="true"></div> <span data-i18n="layer_topo">Topographisch (OSM)</span></button>
        <button onclick="setBaseLayer('osm')" role="menuitem" id="btn-osm" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2 border-t border-white/5 mt-1 pt-2 focus:outline-none focus:ring-2 focus:ring-blue-500"><div class="w-3 h-3 rounded-full bg-emerald-500" aria-hidden="true"></div> <span data-i18n="layer_osm">OSM (Intl)</span></button>
        <button onclick="setBaseLayer('osmde')" role="menuitem" id="btn-osmde" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2 focus:outline-none focus:ring-2 focus:ring-blue-500"><div class="w-3 h-3 rounded-full bg-emerald-700" aria-hidden="true"></div> <span data-i18n="layer_osmde">OSM (DE Style)</span></button>
    </div>
</div>

<!-- MENÜ FÜR EXPORT -->
<div id="export-menu" role="dialog" aria-labelledby="export-title" aria-modal="true" class="hidden absolute top-20 left-5 z-[1001] w-80 glass-panel rounded-3xl p-6 shadow-2xl text-white border border-white/10">
    <div id="export-setup" class="space-y-5">
        <div class="flex justify-between items-center">
            <h3 id="export-title" class="font-bold text-lg" data-i18n="export_header">Export-Eigenschaften</h3>
            <button onclick="toggleExportMenu()" aria-label="Schließen" class="text-slate-400 hover:text-white focus:outline-none focus:text-white text-2xl leading-none">&times;</button>
        </div>
        <div class="space-y-2">
            <label class="text-[10px] uppercase font-bold text-slate-500 tracking-wider" data-i18n="format_label">Format-Vorlage (Verhältnis)</label>
            <div class="grid grid-cols-3 gap-2" role="group" aria-label="Format-Auswahl">
                <button onclick="setExportFormat('free')" id="fmt-free" class="fmt-btn bg-white/10 p-2 rounded-xl text-[10px] font-bold border border-blue-400/50 text-blue-400 active focus:outline-none focus:ring-2 focus:ring-blue-500" data-i18n="fmt_free">FREI</button>
                <button onclick="setExportFormat('a4l')" id="fmt-a4l" class="fmt-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10 focus:outline-none focus:ring-2 focus:ring-blue-500" data-i18n="fmt_a4l">DIN QUER</button>
                <button onclick="setExportFormat('a4p')" id="fmt-a4p" class="fmt-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10 focus:outline-none focus:ring-2 focus:ring-blue-500" data-i18n="fmt_a4p">DIN HOCH</button>
            </div>
        </div>
        <div class="space-y-2">
            <label class="text-[10px] uppercase font-bold text-slate-500 tracking-wider" data-i18n="zoom_label">Detail-Grad (Zoom)</label>
            <div class="grid grid-cols-4 gap-2" role="group" aria-label="Zoom-Auswahl">
                <button onclick="setExportZoom(15)" id="zoom-15" class="zoom-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10 focus:outline-none focus:ring-2 focus:ring-blue-500">Z15</button>
                <button onclick="setExportZoom(16)" id="zoom-16" class="zoom-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10 focus:outline-none focus:ring-2 focus:ring-blue-500">Z16</button>
                <button onclick="setExportZoom(17)" id="zoom-17" class="zoom-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10 focus:outline-none focus:ring-2 focus:ring-blue-500">Z17</button>
                <button onclick="setExportZoom(18)" id="zoom-18" class="zoom-btn bg-white/10 p-2 rounded-xl text-[10px] font-bold border border-blue-400/50 text-blue-400 active focus:outline-none focus:ring-2 focus:ring-blue-500">Z18</button>
            </div>
        </div>
        <button onclick="startSelection()" id="select-btn" class="w-full bg-slate-800 hover:bg-slate-700 py-3 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 border border-white/10 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122" /></svg>
            <span data-i18n="select_area_btn">Ausschnitt auf Karte wählen</span>
        </button>
        <div id="selection-info" class="hidden text-[11px] text-emerald-400 bg-emerald-400/10 p-2 rounded-lg text-center border border-emerald-400/20" data-i18n="area_fixed">Ausschnitt fixiert ✓</div>
        <button id="png-btn" onclick="exportAsPNG()" class="w-full bg-blue-600 hover:bg-blue-500 disabled:opacity-30 disabled:cursor-not-allowed py-3 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-300"><span data-i18n="png_btn">Hydrantenplan (PNG)</span></button>
        <button id="gpx-btn" onclick="exportAsGPX()" class="w-full bg-emerald-600 hover:bg-emerald-500 py-3 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 shadow-lg border border-emerald-400/30 focus:outline-none focus:ring-2 focus:ring-emerald-300">
            <svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
            <span data-i18n="gpx_btn">Hydranten exportieren (GPX)</span>
        </button>
    </div>
    
    <div id="export-progress" class="hidden" role="status">
        <div class="flex justify-between items-center mb-4"><h3 class="font-bold text-lg exporting-active text-blue-400" data-i18n="exporting_title">Export wird erstellt...</h3></div>
        <div class="space-y-4">
            <div>
                <div class="flex justify-between text-[10px] mb-1 uppercase tracking-widest text-blue-400 font-bold"><span id="progress-label" data-i18n="loading_tiles">Lade Kacheln...</span><span id="progress-percent">0%</span></div>
                <div class="h-2 w-full bg-slate-800 rounded-full overflow-hidden"><div id="progress-bar" class="h-full bg-blue-500 w-0 transition-all duration-300"></div></div>
            </div>
            <button onclick="cancelExport()" class="w-full bg-red-500/10 hover:bg-red-500/20 text-red-400 py-2 rounded-xl text-sm font-semibold border border-red-500/20 focus:outline-none focus:ring-2 focus:ring-red-500" data-i18n="cancel_btn">Vorgang abbrechen</button>
        </div>
    </div>
</div>

<div class="absolute bottom-10 right-10 z-[1000] glass-panel p-4 rounded-2xl text-[10px] text-slate-400 font-mono border border-white/5">
    <div class="flex justify-between gap-4"><span data-i18n="zoom_info">ZOOM</span><span id="zoom-val" class="text-white font-bold">14.0</span></div>
    <div class="flex justify-between gap-4"><span data-i18n="data_info">DATEN</span><span id="data-status" class="text-green-400">AKTUELL</span></div>
</div>

<!-- JAVASCRIPT LOGIK -->
<script>
    /* =========================================================================
       1. SPRACH-LOGIK (UPDATE: ERWEITERTE CHINESISCH-ERKENNUNG)
       Die Variable 'translations' kommt jetzt aus der Datei translations.js
       ========================================================================= */
    
    // Ermitteln der Browsersprache (z.B. "de-DE", "zh-TW")
    const userLangFull = navigator.language || navigator.userLanguage; 
    const userLangFullLower = userLangFull.toLowerCase();
    
    // Ermitteln des Kurzcodes (z.B. "de", "zh")
    const userLangShort = userLangFull.split('-')[0];
    
    // Standard-Sprache setzen (Default: Englisch)
    let detectedLang = 'en';

    // Spezial-Logik für Chinesische Varianten
    if (userLangFullLower === 'zh-tw') {
        // Taiwan -> Traditionelles Chinesisch (TW)
        detectedLang = 'tw';
    } else if (userLangFullLower === 'zh-hk' || userLangFullLower === 'zh-mo') {
        // Hongkong / Macau -> Kantonesisch / Traditionell (YUE)
        detectedLang = 'yue';
    } else if (userLangShort === 'zh') {
        // Alle anderen "zh" (z.B. zh-CN, zh-SG) -> Mandarin / Vereinfacht (ZH)
        detectedLang = 'zh';
    } else {
        // Standard-Logik für alle anderen Sprachen
        // Wenn Kurzcode in translations vorhanden ist, nimm ihn, sonst Englisch
        if (typeof translations !== 'undefined' && translations[userLangShort]) {
            detectedLang = userLangShort;
        }
    }

    // Globale Variable für die aktuelle Sprache setzen
    const currentLang = detectedLang;
    
    // Hilfsfunktion: Liefert den übersetzten Text für einen Schlüssel
    function t(key) {
        if (typeof translations === 'undefined') return key; // Fallback, falls JS nicht geladen
        return translations[currentLang][key] || translations['en'][key] || key;
    }

    // Tauscht alle Texte im HTML aus
    function updatePageLanguage() {
        if (typeof translations === 'undefined') return;

        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n'); 
            el.innerText = t(key);
        });
        document.querySelectorAll('[data-i18n-title]').forEach(el => {
            const key = el.getAttribute('data-i18n-title');
            el.title = t(key);
        });
        document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
            const key = el.getAttribute('data-i18n-placeholder');
            el.placeholder = t(key);
        });
    }

    /* 2. ZENTRALE VARIABLEN
       Hier speichern wir den Zustand der App (welche Karte, welche Daten etc.)
    */

    let map;                    // Das Leaflet-Karten-Objekt
    let markerLayer;            // Eine "Folie" für alle Marker (Hydranten etc.)
    let boundaryLayer;          // Eine "Folie" für die Gemeindegrenzen
    let rangeLayerGroup;        // Eine "Folie" für den orangenen 100m-Kreis
    let activeRangeCenter = null; // Welcher Hydrant wurde zuletzt angeklickt?
    
    // Diese Controller helfen uns, laufende Internet-Anfragen abzubrechen,
    // wenn der Benutzer z.B. wild auf der Karte herumschiebt.
    let currentRequestController; 
    let exportAbortController;    
    
    let cachedElements = [];    // Hier speichern wir die geladenen Daten (Cache)
    let activeLayerConfig = 'voyager'; // Welches Design (Standard, Satellit) ist aktiv?
    let exportFormat = 'free';  // Papierformat für Export (A4 oder Frei)
    let exportZoomLevel = 18;   // Gewünschte Qualität für Export
    let isSelecting = false, selectionRect = null, startPoint = null, finalBounds = null; // Für das Auswahl-Rechteck

    // NEU: Debounce Timer (Wartezeit-Logik)
    let debounceTimer = null;

    // Adressen der Karten-Server (Woher kommen die Bilder?)
    const layerUrls = {
        voyager: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
        positron: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
        dark: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
        satellite: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        topo: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
        osm: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        osmde: 'https://tile.openstreetmap.de/{z}/{x}/{y}.png'
    };
    
    const layerAttributions = {
        voyager: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        positron: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        dark: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        satellite: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
        topo: 'Kartendaten: &copy; <a href="https://openstreetmap.org/copyright">OpenStreetMap</a>-Mitwirkende, SRTM | Kartendarstellung: &copy; <a href="http://opentopomap.org">OpenTopoMap</a> (<a href="https://creativecommons.org/licenses/by-sa/3.0/">CC-BY-SA</a>)',
        osm: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        osmde: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    };

    const layerAttributionsText = {
        voyager: '© OpenStreetMap contributors, © CARTO',
        positron: '© OpenStreetMap contributors, © CARTO',
        dark: '© OpenStreetMap contributors, © CARTO',
        satellite: 'Tiles © Esri — Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, GIS Community',
        topo: 'Daten: © OpenStreetMap-Mitwirkende, SRTM | Darstellung: © OpenTopoMap (CC-BY-SA)',
        osm: '© OpenStreetMap contributors',
        osmde: '© OpenStreetMap contributors'
    };

    const layerMaxZoom = { voyager: 18, positron: 18, dark: 18, satellite: 18, topo: 17, osm: 18, osmde: 18 };
    const overpassEndpoints = ['https://overpass-api.de/api/interpreter', 'https://overpass.kumi.systems/api/interpreter'];

    /* =========================================================================
       3. KARTEN START (INITIALISIERUNG)
       Diese Funktion läuft los, sobald die Webseite geladen ist.
       ========================================================================= */
    
    function showNotification(msg, duration = 3000) {
        const box = document.getElementById('notification-box');
        if (!box) return;
        box.innerText = msg;
        box.style.display = 'block';
        if(box.hideTimeout) clearTimeout(box.hideTimeout);
        box.hideTimeout = setTimeout(() => box.style.display = 'none', duration); 
    }

    function initMap() {
        updatePageLanguage(); // Sprache setzen
        setupMenuAutoClose(); // Smart Menu Logic
        
        // Erstelle die "Folien" (Layer Groups)
        markerLayer = L.layerGroup();
        boundaryLayer = L.layerGroup(); 
        rangeLayerGroup = L.layerGroup(); 
        
        // Erstelle die Karte und setze Startpunkt auf Schnaittach
        map = L.map('map', { zoomControl: false, center: [49.555, 11.350], zoom: 14 });
        
        // Standard-Hintergrund laden
        setBaseLayer('voyager'); 
        
        // Folien auf die Karte legen
        boundaryLayer.addTo(map); 
        rangeLayerGroup.addTo(map); 
        markerLayer.addTo(map);   
        
        // Event Listener: Was passiert wann?
        
        // UPDATE: Nutze jetzt die "debounced" (verzögerte) Funktion
        map.on('moveend zoomend', onMapMoveDebounced); 
        
        map.on('zoomend', updateRangeCircle);    
        map.on('zoom', () => document.getElementById('zoom-val').innerText = map.getZoom().toFixed(1)); 
        
        map.on('mousedown', onMouseDown);
        map.on('mousemove', onMouseMove);
        map.on('mouseup', onMouseUp);
        
        map.on('click', () => {
            if (activeRangeCenter && !isSelecting) {
                activeRangeCenter = null;
                updateRangeCircle();
            }
        });

        fetchOSMData(); // Erstes Laden ohne Verzögerung
    }

    /* =========================================================================
       NEU: DEBOUNCE LOGIK (Verzögertes Laden)
       ========================================================================= */
    function onMapMoveDebounced() {
        // 1. Alten Timer löschen (falls der Nutzer noch weiter schiebt)
        if (debounceTimer) {
            clearTimeout(debounceTimer);
        }

        // 2. Status sofort auf "WARTE..." (Orange) setzen
        const statusEl = document.getElementById('data-status');
        statusEl.innerText = t('status_waiting');
        statusEl.className = 'text-amber-400 font-bold'; // Gelb/Orange für "Warten"

        // 3. Neuen Timer starten (200ms warten)
        debounceTimer = setTimeout(() => {
            fetchOSMData(); // Erst jetzt wirklich laden!
        }, 200);
    }

    /* =========================================================================
       NEU: INTELLIGENTE MENÜ-STEUERUNG
       "Smart Auto-Close" für Layer-, Export- und Info-Menüs.
       ========================================================================= */

    // Schließt alle offenen Menüs sofort
    function closeAllMenus() {
        // 1. Layer Menü
        const layerMenu = document.getElementById('layer-menu');
        const layerBtn = document.getElementById('layer-btn-trigger');
        if (layerMenu && !layerMenu.classList.contains('hidden')) {
            layerMenu.classList.add('hidden');
            if(layerBtn) layerBtn.setAttribute('aria-expanded', 'false');
        }

        // 2. Export Menü
        const exportMenu = document.getElementById('export-menu');
        const exportBtn = document.getElementById('export-btn-trigger');
        if (exportMenu && !exportMenu.classList.contains('hidden')) {
            exportMenu.classList.add('hidden');
            if(exportBtn) exportBtn.setAttribute('aria-expanded', 'false');
        }

        // 3. Info / Recht Modal (hat spezielles "flex" styling)
        const legalModal = document.getElementById('legal-modal');
        const legalBtn = document.getElementById('btn-legal-trigger');
        if (legalModal && legalModal.style.display !== 'none' && legalModal.style.display !== '') {
            legalModal.style.display = 'none';
            if(legalBtn) legalBtn.setAttribute('aria-expanded', 'false');
        }
    }

    // Initialisiert die 10-Sekunden Timer für alle Menü-Container
    function setupMenuAutoClose() {
        const menuIds = ['layer-menu', 'export-menu', 'legal-modal'];
        
        menuIds.forEach(id => {
            const el = document.getElementById(id);
            if (!el) return;

            let closeTimer = null;

            // Wenn Maus das Menü verlässt -> 10s Timer starten
            el.addEventListener('mouseleave', () => {
                // Nur starten, wenn das Menü auch wirklich offen ist
                const isHidden = id === 'legal-modal' ? (el.style.display === 'none' || el.style.display === '') : el.classList.contains('hidden');
                if (isHidden) return;

                closeTimer = setTimeout(() => {
                    if (id === 'legal-modal') {
                        el.style.display = 'none';
                        const btn = document.getElementById('btn-legal-trigger');
                        if(btn) btn.setAttribute('aria-expanded', 'false');
                    } else {
                        el.classList.add('hidden');
                        // Finde den passenden Trigger-Button für ARIA
                        const btnId = id === 'layer-menu' ? 'layer-btn-trigger' : 'export-btn-trigger';
                        const btn = document.getElementById(btnId);
                        if(btn) btn.setAttribute('aria-expanded', 'false');
                    }
                }, 10000); // 10 Sekunden
            });

            // Wenn Maus zurückkehrt -> Timer abbrechen
            el.addEventListener('mouseenter', () => {
                if (closeTimer) {
                    clearTimeout(closeTimer);
                    closeTimer = null;
                }
            });
        });
    }

    /* =========================================================================
       4. DATEN LADEN (OVERPASS API)
       ========================================================================= */
    
    async function fetchWithRetry(query) {
        for (let endpoint of overpassEndpoints) {
            try {
                const res = await fetch(`${endpoint}?data=${encodeURIComponent(query)}`, { signal: currentRequestController.signal });
                if (!res.ok) continue; 
                const text = await res.text();
                if (text.trim().startsWith('<?xml') || text.trim().startsWith('<html')) continue;
                return JSON.parse(text); 
            } catch (e) { if (e.name === 'AbortError') throw e; } 
        }
        throw new Error("API Fehler");
    }

    async function fetchOSMData() {
        const zoom = map.getZoom();
        const status = document.getElementById('data-status');
        
        // Standby-Modus (Rausgezoomt)
        if (zoom < 12) {
            status.innerText = t('status_standby');
            status.className = 'text-green-400'; // Grün für "Alles OK" (auch wenn Standby) 
            cachedElements = [];
            markerLayer.clearLayers();
            boundaryLayer.clearLayers();
            return; 
        }
        
        const b = map.getBounds();
        const bbox = `${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()}`;
        
        // Status auf "LADEN" setzen
        status.innerText = t('status_loading'); 
        status.className = 'text-green-400'; // Oder Blau? Ich lasse es Grün wie zuvor
        
        if (currentRequestController) currentRequestController.abort();
        currentRequestController = new AbortController();
        
        let queryParts = [];
        
        if (zoom >= 12) {
            queryParts.push(`nwr["amenity"="fire_station"](${bbox});`);
            queryParts.push(`nwr["building"="fire_station"](${bbox});`);
        }
        if (zoom >= 15) {
            queryParts.push(`nwr["emergency"~"fire_hydrant|water_tank|suction_point|fire_water_pond|cistern"](${bbox});`);
        }
        if (zoom >= 15) {
            queryParts.push(`node["emergency"="defibrillator"](${bbox});`);
        }

        let boundaryQuery = '';
        if (zoom >= 14) {
            boundaryQuery = `(way["boundary"="administrative"]["admin_level"="8"](${bbox});)->.boundaries; .boundaries out geom;`;
        }

        if (queryParts.length === 0 && boundaryQuery === '') return;

        let q = `[out:json][timeout:90];
        (
          ${queryParts.join('\n')}
        )->.pois;
        .pois out center;
        ${boundaryQuery}`;
        
        try {
            const data = await fetchWithRetry(q);
            cachedElements = data.elements; // Daten merken
            renderMarkers(data.elements, zoom); // Auf Karte malen
            status.innerText = t('status_current'); 
            status.className = 'text-green-400';
        } catch (e) { 
            if (e.name !== 'AbortError') {
                status.innerText = t('status_error');
                status.className = 'text-red-500 font-bold';
            }
        }
    }

    /* =========================================================================
       5. DARSTELLUNG (RENDERING)
       ========================================================================= */
    
    function getSVGContent(type) {
        if (type === 'defibrillator') {
             return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <circle cx="50" cy="50" r="45" fill="#16a34a" stroke="white" stroke-width="5"/>
                <path d="M50 80 C10 40 10 10 50 35 C90 10 90 40 50 80 Z" fill="white"/>
                <path d="M55 45 L45 55 L55 55 L45 65" stroke="#16a34a" stroke-width="3" fill="none"/>
            </svg>`;
        }

        const isWater = ['water_tank', 'cistern', 'fire_water_pond', 'suction_point'].includes(type);
        const color = isWater ? '#3b82f6' : '#ef4444'; 
        
        if (type === 'wall') {
             return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <circle cx="50" cy="50" r="45" fill="${color}" stroke="white" stroke-width="5"/>
                <circle cx="42" cy="52" r="18" fill="none" stroke="white" stroke-width="6" />
                <line x1="64" y1="34" x2="64" y2="70" stroke="white" stroke-width="6" stroke-linecap="round" />
            </svg>`;
        }
        
        let char = '';
        switch(type) {
            case 'underground': char = 'U'; break; 
            case 'pillar':      char = 'O'; break; 
            case 'pipe':        char = 'I'; break;
            case 'dry_barrel':  char = 'Ø'; break; 
            default:            char = '';
        }
        
        if (type === 'station') return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M10 40 L50 5 L90 40 L90 90 L10 90 Z" fill="#ef4444" stroke="white" stroke-width="4"/><rect x="30" y="55" width="40" height="35" rx="2" fill="white" opacity="0.9"/></svg>`;
        
        return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="45" fill="${color}" stroke="white" stroke-width="5"/>${char ? `<text x="50" y="72" font-family="Arial" font-weight="bold" font-size="50" text-anchor="middle" fill="white">${char}</text>` : ''}</svg>`;
    }

    // Platziert die Marker auf der Karte (MIT NEUER TOOLTIP LOGIK)
    function renderMarkers(elements, zoom) {
        markerLayer.clearLayers(); 
        boundaryLayer.clearLayers(); 
        const renderedLocations = []; 
        
        elements.forEach(el => {
            const tags = el.tags || {};
            if (tags.boundary === 'administrative' && el.geometry) {
                if (zoom < 14) return; 
                const latlngs = el.geometry.map(p => [p.lat, p.lon]);
                L.polyline(latlngs, { color: '#333333', weight: 1, dashArray: '10, 10', opacity: 0.7 }).addTo(boundaryLayer);
                return; 
            }
            
            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            if (!lat || !lon) return;

            const isStation = tags.amenity === 'fire_station' || tags.building === 'fire_station';
            const isDefib = tags.emergency === 'defibrillator';
            let type = '';

            if (isStation) type = 'station';
            else if (isDefib) type = 'defibrillator';
            else type = tags['fire_hydrant:type'] || tags.emergency;

            if (isStation && zoom < 12) return; 
            if (!isStation && !isDefib && zoom < 15) return; 
            if (isDefib && zoom < 15) return; 

            const alreadyDrawn = renderedLocations.some(loc => Math.abs(loc.lat - lat) < 0.0001 && Math.abs(loc.lon - lon) < 0.0001);
            if (isStation && alreadyDrawn) return;
            if (isStation) renderedLocations.push({lat, lon});

            let marker = null;

            // --- STATIONEN ---
            if (isStation) {
                if (zoom < 14) {
                     L.marker([lat, lon], { icon: L.divIcon({ html: '<div class="station-square"></div>', iconSize: [10,10] }) }).addTo(markerLayer);
                } else {
                     const iconHtml = getSVGContent(type);
                     marker = L.marker([lat, lon], { icon: L.divIcon({ className: 'icon-container', html: iconHtml, iconSize: [32, 32] }), zIndexOffset: 1000 }).addTo(markerLayer);
                }
            } 
            // --- DEFIBRILLATOREN ---
            else if (isDefib) {
                if (zoom < 17) {
                    L.marker([lat, lon], { icon: L.divIcon({ className: 'defib-dot', iconSize: [10,10] }) }).addTo(markerLayer);
                } else {
                    const iconHtml = getSVGContent(type);
                    marker = L.marker([lat, lon], { icon: L.divIcon({ className: 'icon-container', html: iconHtml, iconSize: [28, 28] }), zIndexOffset: 2000 }).addTo(markerLayer);
                }
            } 
            // --- HYDRANTEN ---
            else {
                if (zoom < 17) {
                    const color = ['water_tank', 'cistern', 'fire_water_pond', 'suction_point'].includes(type) ? 'tank-dot' : 'hydrant-dot';
                    L.marker([lat, lon], { icon: L.divIcon({ className: color, iconSize: [10,10] }) }).addTo(markerLayer);
                } else {
                    const iconHtml = getSVGContent(type);
                    marker = L.marker([lat, lon], { icon: L.divIcon({ className: 'icon-container', html: iconHtml, iconSize: [28, 28] }), zIndexOffset: 0 }).addTo(markerLayer);
                    // Radius-Kreis beim Klicken
                    marker.on('click', (e) => { L.DomEvent.stopPropagation(e); showRangeCircle(lat, lon); });
                }
            }

            // --- NEU: SMART TOOLTIP LOGIK (Nur bei Zoom 18) ---
            if (marker && zoom === 18) {
                // 1. Tooltip Konfiguration (binden, damit Leaflet Position kennt)
                marker.bindTooltip(generateTooltip(tags), { 
                    interactive: true,    // Erlaubt Interaktion (wichtig für Copy/Paste)
                    permanent: false,     // Nicht dauerhaft anzeigen
                    sticky: false,        // Feste Position relativ zum Marker
                    direction: 'top',     // Immer oberhalb
                    opacity: 0.95 
                });

                // 2. WICHTIG: Standard-Verhalten von Leaflet deaktivieren!
                // Leaflet fügt beim bindTooltip automatisch Listener für 'mouseover' (öffnen)
                // und 'mouseout' (sofort schließen) hinzu. Diese müssen weg, damit wir
                // die Kontrolle über den Schließ-Zeitpunkt haben.
                marker.off('mouseover'); 
                marker.off('mouseout');

                // Timer-Variable initialisieren
                marker._tooltipCloseTimer = null;

                // 3. Eigene Öffnen-Logik (Sofort bei MouseOver)
                marker.on('mouseover', function() {
                    // Falls gerade ein Schließ-Timer läuft (User kam zurück), abbrechen!
                    if (this._tooltipCloseTimer) {
                        clearTimeout(this._tooltipCloseTimer); 
                        this._tooltipCloseTimer = null;
                    }
                    this.openTooltip(); // Manuell öffnen
                });

                // 4. Eigene Schließen-Logik (Verzögert bei MouseOut)
                marker.on('mouseout', function() {
                    // Timer starten: Schließe erst in 3000ms (3 Sekunden)
                    this._tooltipCloseTimer = setTimeout(() => {
                        this.closeTooltip();
                    }, 3000);
                });

                // 5. Sonderlogik: Maus fährt auf den Tooltip-Text selbst
                // Wir müssen warten, bis der Tooltip wirklich "da" ist ('tooltipopen' Event)
                marker.on('tooltipopen', function(e) {
                    const tooltipNode = e.tooltip._container; // Das HTML-Element des Tooltips
                    if (!tooltipNode) return;

                    // Wenn Maus AUF den Tooltip geht -> Timer stoppen (User liest gerade)
                    L.DomEvent.on(tooltipNode, 'mouseenter', () => {
                        if (this._tooltipCloseTimer) {
                            clearTimeout(this._tooltipCloseTimer);
                            this._tooltipCloseTimer = null;
                        }
                    });

                    // Wenn Maus den Tooltip verlässt -> Timer neu starten (3 Sekunden)
                    L.DomEvent.on(tooltipNode, 'mouseleave', () => {
                        this._tooltipCloseTimer = setTimeout(() => {
                            this.closeTooltip();
                        }, 3000);
                    });
                });
            }
        });
    }

    function generateTooltip(tags) {
        let tooltipTitle = tags.name || t('details');
        if (tags.emergency === 'defibrillator') tooltipTitle = t('defib');

        let html = `<div class="p-2 min-w-[180px]">
            <div class="font-bold text-sm border-b border-white/20 pb-1 mb-1 text-blue-400">${tooltipTitle}</div>
            <div class="text-[10px] font-mono grid grid-cols-[auto_1fr] gap-x-2 gap-y-1">`;
        for (const [key, val] of Object.entries(tags)) {
            html += `<div class="text-slate-400 text-right">${key}:</div><div class="text-slate-200 break-words">${val}</div>`;
        }
        html += `</div></div>`;
        return html;
    }

    function showRangeCircle(lat, lon) {
        activeRangeCenter = {lat, lon};
        updateRangeCircle();
    }

    function updateRangeCircle() {
        rangeLayerGroup.clearLayers();
        if (!activeRangeCenter) return;
        const zoom = map.getZoom();
        if (zoom < 16) return; 

        L.circle([activeRangeCenter.lat, activeRangeCenter.lon], {
            color: '#f97316', fillColor: '#f97316', fillOpacity: 0.15, radius: 100, weight: 2, dashArray: '5, 8', interactive: false 
        }).addTo(rangeLayerGroup);

        if (zoom >= 17) {
            const latRad = activeRangeCenter.lat * Math.PI / 180;
            const kmPerDegLon = 111.32 * Math.cos(latRad);
            const offsetLon = 0.05 / kmPerDegLon; 
            const labelPos = [activeRangeCenter.lat, activeRangeCenter.lon + offsetLon];
            const labelMarker = L.marker(labelPos, {opacity: 0, interactive: false}).addTo(rangeLayerGroup);
            labelMarker.bindTooltip("100 m", { permanent: true, direction: 'center', className: 'range-label', offset: [0, 0] }).openTooltip();
        }
    }

    function locateUser() {
        if (!navigator.geolocation) { showNotification(t('geo_error')); return; }
        const btn = document.getElementById('locate-btn');
        const icon = btn ? btn.querySelector('svg') : null;
        if(icon) icon.classList.add('animate-spin'); 

        navigator.geolocation.getCurrentPosition(
            (pos) => {
                const { latitude, longitude } = pos.coords;
                map.flyTo([latitude, longitude], 18, { animate: true, duration: 1.5 });
                if(icon) icon.classList.remove('animate-spin');
                showNotification(t('geo_found'));
            },
            (err) => {
                console.warn("Geolocation Fehler:", err);
                if(icon) icon.classList.remove('animate-spin');
                showNotification(t('geo_fail'));
            },
            { enableHighAccuracy: true, timeout: 5000 }
        );
    }

    /* =========================================================================
       6. EXPORT & MENÜ FUNKTIONEN (UPDATE: EXKLUSIVES ÖFFNEN)
       ========================================================================= */
    function setExportFormat(fmt) {
        exportFormat = fmt;
        document.querySelectorAll('.fmt-btn').forEach(b => {
            b.classList.remove('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
            b.classList.add('bg-white/5');
        });
        document.getElementById(`fmt-${fmt}`).classList.add('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
        clearSelection(); 
    }

    function setExportZoom(z) {
        if (activeLayerConfig === 'topo' && z > 17) return; 
        exportZoomLevel = z;
        document.querySelectorAll('.zoom-btn').forEach(b => {
            b.classList.remove('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
            b.classList.add('bg-white/5');
        });
        const activeBtn = document.getElementById(`zoom-${z}`);
        if(activeBtn) {
            activeBtn.classList.add('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
            activeBtn.classList.remove('bg-white/5');
        }
    }

    function startSelection() {
        isSelecting = true;
        clearSelection();
        map.dragging.disable(); 
        map.getContainer().classList.add('selection-mode'); 
        showNotification(t('drag_area')); 
    }

    function clearSelection() {
        if (selectionRect) { map.removeLayer(selectionRect); selectionRect = null; }
        finalBounds = null;
        document.getElementById('selection-info').classList.add('hidden');
    }

    function onMouseDown(e) {
        if (!isSelecting) return;
        startPoint = e.latlng;
        selectionRect = L.rectangle([startPoint, startPoint], {
            color: '#3b82f6', weight: 2, fillOpacity: 0.2, interactive: false
        }).addTo(map);
    }

    function onMouseMove(e) {
        if (!isSelecting || !startPoint || !selectionRect) return;
        let current = e.latlng;
        if (exportFormat !== 'free') {
            const ratio = (exportFormat === 'a4l') ? 1.4142 : 0.7071; 
            const lngScale = Math.cos(startPoint.lat * Math.PI / 180);
            const dy = Math.abs(current.lat - startPoint.lat);
            const dx = (dy * ratio) / lngScale;
            const latDir = current.lat > startPoint.lat ? 1 : -1;
            const lngDir = current.lng > startPoint.lng ? 1 : -1;
            current = L.latLng(startPoint.lat + (latDir * dy), startPoint.lng + (lngDir * dx));
        }
        selectionRect.setBounds([startPoint, current]);
    }

    function onMouseUp(e) {
        if (!isSelecting || !startPoint) return;
        finalBounds = selectionRect.getBounds(); 
        isSelecting = false; startPoint = null;
        map.dragging.enable(); 
        map.getContainer().classList.remove('selection-mode');
        document.getElementById('selection-info').classList.remove('hidden');
    }

    function setBaseLayer(key) {
        activeLayerConfig = key;
        map.eachLayer(layer => { if (layer instanceof L.TileLayer) map.removeLayer(layer); });
        
        const attribution = layerAttributions[key] || '&copy; OSM';
        L.tileLayer(layerUrls[key], { attribution: attribution }).addTo(map);
        
        document.querySelectorAll('.layer-btn').forEach(btn => btn.classList.remove('active'));
        const activeBtn = document.getElementById(`btn-${key}`);
        if(activeBtn) activeBtn.classList.add('active');
        const btn18 = document.getElementById('zoom-18');
        if (key === 'topo') {
            btn18.disabled = true;
            if (exportZoomLevel > 17) setExportZoom(17);
        } else {
            btn18.disabled = false;
        }
    }

    // UPDATE: Toggle-Funktionen nutzen jetzt closeAllMenus() für exklusives Öffnen
    function toggleExportMenu() { 
        const menu = document.getElementById('export-menu');
        const btn = document.getElementById('export-btn-trigger');
        const isCurrentlyHidden = menu.classList.contains('hidden');
        
        // Erst alles schließen (damit Layer-Menü zugeht, falls offen)
        closeAllMenus();

        // Wenn es vorher zu war, machen wir es jetzt auf (ansonsten bleibt es zu, weil closeAllMenus es schon zugemacht hat)
        if (isCurrentlyHidden) {
            menu.classList.remove('hidden');
            btn.setAttribute('aria-expanded', 'true');
            resetExportUI();
        }
    }

    function toggleLayerMenu() { 
        const menu = document.getElementById('layer-menu');
        const btn = document.getElementById('layer-btn-trigger');
        const isCurrentlyHidden = menu.classList.contains('hidden');
        
        closeAllMenus(); // Andere Menüs schließen

        if (isCurrentlyHidden) {
            menu.classList.remove('hidden');
            btn.setAttribute('aria-expanded', 'true');
        }
    }

    function toggleLegalModal() { 
        const modal = document.getElementById('legal-modal');
        const btn = document.getElementById('btn-legal-trigger');
        const isCurrentlyVisible = (modal.style.display === 'flex');
        
        closeAllMenus(); // Andere Menüs schließen

        if (!isCurrentlyVisible) {
            modal.style.display = 'flex';
            btn.setAttribute('aria-expanded', 'true');
        }
    }

    function resetExportUI() {
        document.getElementById('export-setup').classList.remove('hidden');
        document.getElementById('export-progress').classList.add('hidden');
        document.getElementById('progress-bar').style.width = '0%';
    }
    function cancelExport() { if(exportAbortController) exportAbortController.abort(); }

    function searchLocation() {
        const q = document.getElementById('search-input').value;
        if (!q) return;
        fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`).then(r => r.json()).then(d => { if(d.length) map.flyTo([d[0].lat, d[0].lon], 18); });
    }

    /* =========================================================================
       7. EXPORT FUNKTIONEN (GPX & PNG)
       ========================================================================= */
    
    function exportAsGPX() {
        const bounds = finalBounds || map.getBounds();
        const pointsToExport = cachedElements.filter(el => {
            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            if (!lat || !lon) return false;
            return bounds.contains(L.latLng(lat, lon));
        });

        if (pointsToExport.length === 0) {
            showNotification(t('no_objects'));
            return;
        }

        let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n';
        gpx += '<gpx version="1.1" creator="OpenFireMap V2" xmlns="http://www.topografix.com/GPX/1/1">\n';
        gpx += `  <metadata><name>Hydranten Export</name><time>${new Date().toISOString()}</time></metadata>\n`;

        pointsToExport.forEach(el => {
            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            const tags = el.tags || {};
            
            const isStation = tags.amenity === 'fire_station' || tags.building === 'fire_station';
            const isHydrant = tags.emergency && ['fire_hydrant', 'water_tank', 'suction_point', 'fire_water_pond', 'cistern'].some(t => tags.emergency.includes(t));
            const isDefib = tags.emergency === 'defibrillator';

            if (!isStation && !isHydrant && !isDefib) return;

            let name = tags.name || (isStation ? t('station') : (isDefib ? t('defib') : t('hydrant')));
            if (!tags.name && tags['fire_hydrant:type']) name = `H ${tags['fire_hydrant:type']}`;
            if (!tags.name && tags['ref']) name = `${isStation ? 'Wache' : 'H'} ${tags['ref']}`;

            let desc = [];
            for (const [k, v] of Object.entries(tags)) {
                desc.push(`${k}: ${v}`);
            }
            
            gpx += `  <wpt lat="${lat}" lon="${lon}">\n`;
            gpx += `    <name>${escapeXML(name)}</name>\n`;
            gpx += `    <desc>${escapeXML(desc.join('\n'))}</desc>\n`;
            gpx += `    <sym>${isStation ? 'Fire Station' : 'Hydrant'}</sym>\n`;
            gpx += `  </wpt>\n`;
        });

        gpx += '</gpx>';

        const blob = new Blob([gpx], {type: 'application/gpx+xml'});
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.download = `OpenFireMap_Export_${new Date().toISOString().slice(0,10)}.gpx`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
        
        showNotification(`${pointsToExport.length} ${t('gpx_success')}`);
        toggleExportMenu();
    }

    function escapeXML(str) {
        return str.replace(/[<>&'"]/g, c => {
            switch (c) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                case '\'': return '&apos;';
                case '"': return '&quot;';
            }
        });
    }

    const ZOOM_LIMITS_KM = {
        12: 30, // Weit rausgezoomt: Großer Ausschnitt erlaubt (30km)
        13: 25,
        14: 20,
        15: 15,
        16: 10,
        17: 8,
        18: 5   // Nah reingezoomt: Kleiner Ausschnitt (5km) wegen Detailreichtum
    };

    async function exportAsPNG() {
        exportAbortController = new AbortController();
        const signal = exportAbortController.signal;
        
        document.getElementById('export-setup').classList.add('hidden');
        document.getElementById('export-progress').classList.remove('hidden');
        const progressBar = document.getElementById('progress-bar'), progressPercent = document.getElementById('progress-percent'), progressLabel = document.getElementById('progress-label');
        
        const targetZoom = exportZoomLevel;
        const fallbackZoom = targetZoom - 1; 
        const bounds = finalBounds || map.getBounds(); 
        const nw = bounds.getNorthWest(), se = bounds.getSouthEast();

        progressLabel.innerText = t('locating'); 
        
        let displayTitle = "OpenFireMap.org";
        const centerLat = bounds.getCenter().lat;
        const centerLon = bounds.getCenter().lng;

        try {
            const fetchAddress = async (lat, lon) => {
                const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18`); 
                const d = await res.json();
                const addr = d.address || {};
                const city = addr.city || addr.town || addr.village || addr.municipality || "";
                const suburb = addr.suburb || addr.neighbourhood || addr.hamlet || "";
                return { city, suburb };
            };

            const centerLoc = await fetchAddress(centerLat, centerLon);
            if (centerLoc.city) {
                displayTitle = centerLoc.suburb ? `${centerLoc.city} - ${centerLoc.suburb}` : centerLoc.city;
            }

            if (targetZoom === 14 || targetZoom === 15) {
                const pointsToCheck = [
                    {lat: nw.lat, lon: nw.lng}, {lat: nw.lat, lon: se.lng}, 
                    {lat: se.lat, lon: se.lng}, {lat: se.lat, lon: nw.lng}  
                ];
                const promises = pointsToCheck.map(p => fetchAddress(p.lat, p.lon));
                const results = await Promise.all(promises);
                results.push(centerLoc);
                const uniqueCities = new Set();
                results.forEach(loc => { if (loc.city) uniqueCities.add(loc.city); });
                if (uniqueCities.size >= 3) displayTitle = "OpenFireMap.org";
            }
        } catch (e) { console.error("Titel Fehler:", e); }

        const worldSize = (z) => Math.pow(2, z);
        const lat2tile = (lat, z) => (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * worldSize(z);
        const lon2tile = (lon, z) => (lon + 180) / 360 * worldSize(z);
        
        const x1 = Math.floor(lon2tile(nw.lng, targetZoom));
        const y1 = Math.floor(lat2tile(nw.lat, targetZoom));
        const x2 = Math.floor(lon2tile(se.lng, targetZoom));
        const y2 = Math.floor(lat2tile(se.lat, targetZoom));

        const margin = 40; 
        const footerH = 60; 
        
        const mapWidth = (x2 - x1 + 1) * 256;
        const mapHeight = (y2 - y1 + 1) * 256;

        const mPerPx = (Math.cos(bounds.getCenter().lat * Math.PI / 180) * 2 * Math.PI * 6378137) / (256 * Math.pow(2, targetZoom));

        const canvas = document.createElement('canvas');
        canvas.width = mapWidth + (margin * 2); 
        canvas.height = mapHeight + margin + footerH + margin; 
        
        if (canvas.width > 14000 || canvas.height > 14000) { 
            showNotification(t('too_large'), 5000); 
            toggleExportMenu(); return; 
        }

        const maxKm = ZOOM_LIMITS_KM[targetZoom] || 5; 
        const maxMeters = maxKm * 1000;
        
        const widthMeters = mapWidth * mPerPx;
        const heightMeters = mapHeight * mPerPx;

        if (widthMeters > maxMeters || heightMeters > maxMeters) {
             const currentMax = Math.max(widthMeters, heightMeters) / 1000;
             const msg = `Zoom ${targetZoom}: Max. ${maxKm}km erlaubt! (Aktuell: ~${currentMax.toFixed(1)}km)`;
             showNotification(msg, 6000); 
             toggleExportMenu(); 
             return;
        }

        const ctx = canvas.getContext('2d');
        
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const totalTiles = (x2 - x1 + 1) * (y2 - y1 + 1);
        let loaded = 0;
        const baseUrlTpl = layerUrls[activeLayerConfig].replace('{s}', 'a').replace('{r}', '');

        progressLabel.innerText = `${t('loading_tiles')} (Z${targetZoom})...`;
        
        const tileQueue = [];
        for (let x = x1; x <= x2; x++) {
            for (let y = y1; y <= y2; y++) {
                tileQueue.push({x, y});
            }
        }

        const CONCURRENCY = 8; 
        const processQueue = async () => {
            while (tileQueue.length > 0 && !signal.aborted) {
                const {x, y} = tileQueue.shift();
                await new Promise(resolve => {
                    const img = new Image(); img.crossOrigin = "anonymous";
                    const zTargetUrl = baseUrlTpl.replace('{z}', targetZoom).replace('{x}', x).replace('{y}', y);
                    img.onload = () => { 
                        ctx.drawImage(img, (x - x1) * 256 + margin, (y - y1) * 256 + margin); 
                        loaded++; updateProgress(); resolve(); 
                    };
                    img.onerror = () => {
                        const zFallback_x = Math.floor(x/2); const zFallback_y = Math.floor(y/2);
                        const off_x = (x % 2) * 128; const off_y = (y % 2) * 128;
                        const zFallbackUrl = baseUrlTpl.replace('{z}', fallbackZoom).replace('{x}', zFallback_x).replace('{y}', zFallback_y);
                        const fImg = new Image(); fImg.crossOrigin = "anonymous"; fImg.src = zFallbackUrl;
                        fImg.onload = () => { 
                            ctx.drawImage(fImg, off_x, off_y, 128, 128, (x - x1) * 256 + margin, (y - y1) * 256 + margin, 256, 256); 
                            loaded++; updateProgress(); resolve(); 
                        };
                        fImg.onerror = () => { loaded++; resolve(); };
                    };
                    img.src = zTargetUrl;
                });
            }
        };

        const workers = [];
        for (let i = 0; i < CONCURRENCY; i++) workers.push(processQueue());
        await Promise.all(workers);

        function updateProgress() { const p = Math.round((loaded / totalTiles) * 80); progressBar.style.width = p + "%"; progressPercent.innerText = p + "%"; }
        if(signal.aborted) { toggleExportMenu(); return; }
        
        progressLabel.innerText = t('render_bounds');
        ctx.save(); 
        ctx.translate((-x1 * 256) + margin, (-y1 * 256) + margin); 
        ctx.strokeStyle = "#333333"; ctx.lineWidth = 2; ctx.setLineDash([20, 20]); ctx.lineCap = "round";

        for (let el of cachedElements) {
            if (el.tags && el.tags.boundary === 'administrative' && el.geometry) {
                if (targetZoom < 14) continue; 
                ctx.beginPath();
                let first = true;
                for (let p of el.geometry) {
                    const px = lon2tile(p.lon, targetZoom) * 256;
                    const py = lat2tile(p.lat, targetZoom) * 256;
                    if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
                }
                ctx.stroke();
            }
        }
        ctx.restore();

        progressLabel.innerText = t('render_infra');
        ctx.save(); 
        ctx.translate((-x1 * 256) + margin, (-y1 * 256) + margin);
        const iconCache = {};
        const renderedExportLocations = []; 

        for (let el of cachedElements) {
            const tags = el.tags || {};
            if (tags.boundary === 'administrative') continue;

            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            const isStation = tags.amenity === 'fire_station' || tags.building === 'fire_station';
            
            if (isStation) {
                const alreadyDrawn = renderedExportLocations.some(loc => Math.abs(loc.lat - lat) < 0.0001 && Math.abs(loc.lon - lon) < 0.0001);
                if (alreadyDrawn) continue;
                renderedExportLocations.push({lat, lon});
            }

            const type = isStation ? 'station' : (tags.emergency === 'defibrillator' ? 'defibrillator' : (tags['fire_hydrant:type'] || tags.emergency));
            const tx = lon2tile(lon, targetZoom) * 256;
            const ty = lat2tile(lat, targetZoom) * 256;
            
            if (tx < x1*256 || tx > (x2+1)*256 || ty < y1*256 || ty > (y2+1)*256) continue;

            if (isStation && targetZoom < 12) continue;
            if (type === 'defibrillator') {
                if (targetZoom < 15) continue;
            } else if (!isStation && targetZoom < 15) continue;

            const drawAsStationSquare = isStation && targetZoom < 14;
            const drawAsHydrantDot = !isStation && type !== 'defibrillator' && targetZoom < 17;
            const drawAsDefibDot = type === 'defibrillator' && targetZoom >= 15 && targetZoom < 17;

            if (drawAsHydrantDot || drawAsStationSquare || drawAsDefibDot) {
                const isWater = ['water_tank', 'cistern', 'fire_water_pond', 'suction_point'].includes(type);
                const color = isStation ? '#ef4444' : (type === 'defibrillator' ? '#16a34a' : (isWater ? '#3b82f6' : '#ef4444'));
                ctx.beginPath();
                if (drawAsStationSquare) ctx.rect(tx - 5, ty - 5, 10, 10); else ctx.arc(tx, ty, 5, 0, 2 * Math.PI);
                ctx.fillStyle = color; ctx.fill(); ctx.lineWidth = 1.5; ctx.strokeStyle = "white"; ctx.stroke();
            } else {
                if (!iconCache[type]) {
                    const svgB = new Blob([getSVGContent(type)], {type: 'image/svg+xml;charset=utf-8'}), url = URL.createObjectURL(svgB), img = new Image();
                    img.src = url; await new Promise(res => img.onload = res); iconCache[type] = img;
                }
                ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 8; ctx.shadowOffsetY = 4;
                const iconScale = targetZoom < 17 ? 0.8 : 1.0; 
                const size = (type === 'station' ? 38 : 34) * iconScale;
                ctx.drawImage(iconCache[type], tx - size/2, ty - size/2, size, size);
                ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
            }
        }
        ctx.restore();

        progressLabel.innerText = t('layout_final');
        const bannerH = 170; 
        ctx.fillStyle = "rgba(255, 255, 255, 0.98)"; 
        ctx.fillRect(margin, margin, mapWidth, bannerH);
        ctx.strokeStyle = "rgba(15, 23, 42, 0.2)"; ctx.lineWidth = 3; 
        
        ctx.strokeRect(margin, margin, mapWidth, bannerH);
        
        ctx.strokeRect(margin, margin + bannerH, mapWidth, mapHeight - bannerH);
        
        const centerX = margin + (mapWidth / 2);

        ctx.fillStyle = "#0f172a"; ctx.textAlign = "center";
        const finalTitle = displayTitle === "OpenFireMap.org" ? "OpenFireMap.org" : `${t('plan_title')} ${displayTitle}`;
        ctx.font = "bold 44px Arial, sans-serif"; ctx.fillText(finalTitle, centerX, margin + 55);
        
        const now = new Date();
        ctx.font = "22px Arial, sans-serif"; ctx.fillStyle = "#334155";
        
        const localeMap = { 
            'de': 'de-DE', 'en': 'en-US', 'fr': 'fr-FR', 'es': 'es-ES', 'it': 'it-IT', 
            'pl': 'pl-PL', 'nl': 'nl-NL', 'cs': 'cs-CZ', 'da': 'da-DK', 'fi': 'fi-FI', 
            'sv': 'sv-SE', 'no': 'nb-NO', 'pt': 'pt-PT', 'fl': 'nl-BE', 'lb': 'lb-LU',
            'ja': 'ja-JP', 'ko': 'ko-KR', 'ms': 'ms-MY', 'th': 'th-TH', 'zh': 'zh-CN',
            'yue': 'zh-HK', 'tw': 'zh-TW'
        };
        const dateLocale = localeMap[currentLang] || 'en-US';
        const dateStr = now.toLocaleDateString(dateLocale, { year: 'numeric', month: 'long' });
        
        ctx.fillText(`${t('legend_date')}: ${dateStr} | ${t('legend_res')}: Zoom ${targetZoom} (~${mPerPx.toFixed(2)} m/px)`, centerX, margin + 95);
        
        ctx.font = "italic 16px Arial, sans-serif"; ctx.fillStyle = "#64748b";
        const attributionText = layerAttributionsText[activeLayerConfig] || '© OpenStreetMap contributors';
        ctx.fillText(attributionText, centerX, margin + 125);

        const prettyD = [1000, 500, 250, 100, 50]; 
        let distM = 100, scaleW = 100 / mPerPx;
        for (let d of prettyD) { let w = d / mPerPx; if (w <= mapWidth * 0.3) { distM = d; scaleW = w; break; } }
        
        const sX = margin + mapWidth - scaleW - 40; 
        const sY = margin + mapHeight - 40;
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)"; ctx.fillRect(sX - 10, sY - 50, scaleW + 20, 60);
        ctx.strokeStyle = "#0f172a"; ctx.lineWidth = 3; 
        ctx.beginPath(); ctx.moveTo(sX, sY - 10); ctx.lineTo(sX, sY); ctx.lineTo(sX + scaleW, sY); ctx.lineTo(sX + scaleW, sY - 10); ctx.stroke();
        ctx.fillStyle = "#0f172a"; ctx.font = "bold 18px Arial"; ctx.fillText(`${distM} m`, sX + scaleW / 2, sY - 15);

        const footerY = margin + mapHeight + (footerH / 2) + 10; 
        ctx.fillStyle = "#334155";
        
        ctx.textAlign = "left"; 
        ctx.font = "16px Arial, sans-serif"; 
        ctx.fillText("OpenFireMap.org", margin, footerY);

        ctx.textAlign = "right";
        ctx.font = "16px Arial, sans-serif";
        const timeStr = now.toLocaleString(dateLocale, { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
        ctx.fillText(timeStr, margin + mapWidth, footerY);

        progressBar.style.width = "100%";
        const link = document.createElement('a'); 
        link.download = `Hydrantenplan_${finalTitle.replace(/[\s\.]/g, '_')}_Z${targetZoom}_${activeLayerConfig}_${now.toISOString().slice(0,10)}.png`;
        link.href = canvas.toDataURL("image/png"); 
        link.click();
        Object.values(iconCache).forEach(img => URL.revokeObjectURL(img.src)); 
        setTimeout(toggleExportMenu, 800);
    }

    document.addEventListener('DOMContentLoaded', initMap);
</script>
</body>
</html>
