<!-- 
    =============================================================================
    PROJEKT: OpenFireMap V2 - High-Res Exporter & GPX Tool (Vollständig Erklärt)
    =============================================================================
    
    Hallo! Dies ist der Quellcode für deine Feuerwehr-Karten-Anwendung.
    
    STRUKTUR DIESER DATEI:
    Diese Datei ist eine "Single Page Application" (SPA). Das heißt, alles, was 
    die App braucht, steckt in dieser einen Textdatei. Du kannst sie einfach im 
    Browser öffnen, und sie läuft – ganz ohne Installation.

    WAS MACHT DIESER CODE?
    1. Er lädt eine Landkarte (Leaflet).
    2. Er fragt eine Datenbank (OpenStreetMap) nach Hydranten, Wachen und AEDs.
    3. Er übersetzt Texte automatisch (Deutsch, Englisch, Französisch etc.).
    4. Er erlaubt den Export als Bild (PNG) oder für Navis (GPX).

    AUTOR: Gemini (im Auftrag von Frank März)
    DATUM: 2026-01-16 (Update: AED Zoom Levels & Dots)
-->
<!DOCTYPE html>
<!-- 'lang="de"' sagt dem Browser, dass die Grundsprache Deutsch ist. -->
<html lang="de">
<head>
    <meta charset="UTF-8">
    <!-- 
        WICHTIG FÜR HANDYS:
        Dieser Befehl sagt dem Handy: "Zeige die Seite so breit an, wie der Bildschirm ist."
        Ohne das wäre die Schrift auf dem Smartphone winzig klein.
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenFireMap.org V2</title>
    
    <!-- 
        EXTERNE WERKZEUGE (Bibliotheken):
        Wir laden hier fertige Bausteine aus dem Internet, damit wir nicht alles selbst programmieren müssen.
    -->
    <!-- Leaflet CSS: Das Design für die Karte (Steuerelemente, Marker) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet JS: Die Logik für die Karte (Zoomen, Verschieben) -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Tailwind CSS: Ein Werkzeugkasten für Design (macht Dinge fett, bunt, rund etc.) -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- CSS (CASCADING STYLE SHEETS) - HIER BESTIMMEN WIR DAS AUSSEHEN -->
    <style>
        /* Grundregeln für die gesamte Seite */
        body { 
            margin: 0; padding: 0; 
            overflow: hidden; /* Verhindert Scrollbalken am Rand - die Karte soll Vollbild sein */
            font-family: sans-serif; 
            background: #0f172a; /* Ein dunkles Blau als Hintergrundfarbe */
        }
        
        /* Der Container, in den die Karte später "gemalt" wird. Er füllt den ganzen Bildschirm. */
        #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #1e293b; }
        
        /* Das Design für die halbtransparenten Menüs ("Glassmorphism") */
        .glass-panel { 
            background: rgba(15, 23, 42, 0.85); /* Dunkelblau, aber 85% undurchsichtig */
            backdrop-filter: blur(12px); /* Der Hintergrund verschwimmt wie Milchglas */
            border: 1px solid rgba(255, 255, 255, 0.1); /* Ein ganz feiner weißer Rand */
        }
        
        /* Styling für die Icons auf der Karte */
        .icon-container { 
            display: flex; align-items: center; justify-content: center; 
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4)); /* Ein kleiner Schatten unter dem Icon */
            transition: transform 0.1s ease; /* Weiche Animation */
        }
        /* Wenn man mit der Maus über ein Icon fährt, wird es 15% größer */
        .icon-container:hover { transform: scale(1.15); z-index: 1000 !important; }

        /* Kleine farbige Punkte für niedrige Zoomstufen (wenn man weit weg ist) */
        .hydrant-dot { background-color: #ef4444; border: 1.5px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        .tank-dot { background-color: #3b82f6; border: 1.5px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        .defib-dot { background-color: #16a34a; border: 1.5px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        .station-square { background-color: #ef4444; border: 1px solid white; width: 10px; height: 10px; box-shadow: 0 0 4px rgba(0,0,0,0.5); }

        /* Das Aussehen der kleinen Info-Schildchen beim Drüberfahren (Tooltips) */
        .leaflet-tooltip { 
            background: #0f172a; 
            color: white; 
            border: 1px solid rgba(255,255,255,0.15); 
            border-radius: 8px; 
            font-size: 12px; 
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6); 
            padding: 0; 
        }

        /* Der Text "100m" am Radius-Kreis */
        .range-label {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            color: #333333 !important; /* Dunkelgraue Schrift */
            font-weight: bold;
            font-size: 14px;
            /* Ein Trick: Weißer Schatten um den Text, damit man ihn auf jedem Untergrund lesen kann */
            text-shadow: -1px -1px 0 rgba(255,255,255,0.8), 1px -1px 0 rgba(255,255,255,0.8), -1px 1px 0 rgba(255,255,255,0.8), 1px 1px 0 rgba(255,255,255,0.8);
        }
        
        /* Markiert den aktiven Button blau */
        .layer-btn.active { color: #3b82f6; background: rgba(59, 130, 246, 0.1); font-weight: bold; }
        
        /* Eine Animation: Rotes Pulsieren (für den Export-Text) */
        @keyframes pulse-red { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .exporting-active { animation: pulse-red 2s infinite; }

        /* Die rote Box für Fehlermeldungen oben rechts */
        #notification-box { 
            position: absolute; top: 20px; right: 20px; z-index: 2000; display: none;
            background: #ef4444; color: white; padding: 12px 24px; border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3); font-weight: 600;
        }

        /* Ändert den Mauszeiger zu einem Fadenkreuz */
        .selection-mode { cursor: crosshair !important; }
        /* Wenn ein Button deaktiviert ist (z.B. Zoom 18 bei Topo-Karte), wird er blass */
        .zoom-btn:disabled { opacity: 0.3; cursor: not-allowed; border-color: transparent; }
    </style>
</head>
<body>

<!-- HTML STRUKTUR (DAS SKELETT) -->

<!-- 1. Der Platzhalter für die Karte -->
<div id="map"></div>
<!-- 2. Die Benachrichtigungsbox (versteckt) -->
<div id="notification-box"></div>

<!-- 
    3. DIE STEUERLEISTE (Oben Links) 
    z-[1000] sorgt dafür, dass sie ÜBER der Karte schwebt.
-->
<div class="absolute top-5 left-5 z-[1000] flex gap-3">
    <!-- Suchfeld -->
    <div class="flex glass-panel rounded-2xl shadow-2xl p-1 border border-white/5">
        <!-- 'data-i18n-placeholder' ist unser Marker für die Übersetzung -->
        <input type="text" id="search-input" data-i18n-placeholder="search_placeholder" placeholder="Ort suchen..." class="bg-transparent px-4 py-2 text-sm text-white outline-none w-48 focus:w-72 transition-all duration-500 placeholder:text-slate-500">
        <button onclick="searchLocation()" class="p-2 text-slate-400 hover:text-white transition-colors">
            <!-- Das hier ist SVG-Code. Das zeichnet das kleine Lupen-Icon. -->
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
        </button>
    </div>
    
    <!-- GPS Button -->
    <button onclick="locateUser()" id="locate-btn" data-i18n-title="locate_title" class="glass-panel p-3 rounded-2xl text-slate-400 hover:text-emerald-400 shadow-2xl transition-all border border-white/10 active:scale-95" title="Mein Standort">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
        </svg>
    </button>
    
    <!-- Layer Button -->
    <button onclick="toggleLayerMenu()" data-i18n-title="layers_title" class="glass-panel p-3 rounded-2xl text-slate-400 hover:text-white shadow-2xl transition-all border border-white/10 active:scale-95" title="Karte wechseln">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
        </svg>
    </button>

    <!-- Export Button -->
    <button onclick="toggleExportMenu()" data-i18n-title="export_title" class="glass-panel p-3 rounded-2xl text-blue-400 hover:text-blue-300 shadow-2xl transition-all border border-blue-500/20 active:scale-95" title="Export">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>
    </button>
</div>

<!-- 4. DAS LAYER MENÜ (Auswahl des Hintergrunds) - Anfangs unsichtbar (class="hidden") -->
<div id="layer-menu" class="hidden absolute top-20 left-28 z-[1001] w-64 glass-panel rounded-2xl p-4 shadow-2xl text-white border border-white/10">
    <h3 class="text-xs font-bold uppercase tracking-wider text-slate-500 mb-3 text-center" data-i18n="bg_header">Hintergrund</h3>
    <div class="grid grid-cols-1 gap-1">
        <!-- data-i18n="..." sagt dem Skript: "Tausche diesen Text gegen die richtige Sprache aus!" -->
        <button onclick="setBaseLayer('voyager')" id="btn-voyager" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-blue-500"></div> <span data-i18n="layer_std">Standard (Voyager)</span>
        </button>
        <button onclick="setBaseLayer('positron')" id="btn-positron" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-slate-300"></div> <span data-i18n="layer_print">Druck (Hell)</span>
        </button>
        <!-- ... weitere Buttons für andere Kartenstile ... -->
        <button onclick="setBaseLayer('dark')" id="btn-dark" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-slate-800"></div> <span data-i18n="layer_night">Nacht (Dunkel)</span>
        </button>
        <button onclick="setBaseLayer('satellite')" id="btn-satellite" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-green-600"></div> <span data-i18n="layer_sat">Satellit (Esri)</span>
        </button>
        <button onclick="setBaseLayer('topo')" id="btn-topo" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-amber-600"></div> <span data-i18n="layer_topo">Topographisch (OSM)</span>
        </button>
        <button onclick="setBaseLayer('osm')" id="btn-osm" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2 border-t border-white/5 mt-1 pt-2">
            <div class="w-3 h-3 rounded-full bg-emerald-500"></div> <span data-i18n="layer_osm">OSM (Intl)</span>
        </button>
        <button onclick="setBaseLayer('osmde')" id="btn-osmde" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-emerald-700"></div> <span data-i18n="layer_osmde">OSM (DE Style)</span>
        </button>
    </div>
</div>

<!-- 5. DAS EXPORT MENÜ (Für PNG und GPX) -->
<div id="export-menu" class="hidden absolute top-20 left-5 z-[1001] w-80 glass-panel rounded-3xl p-6 shadow-2xl text-white border border-white/10">
    
    <!-- Ansicht A: Einstellungen -->
    <div id="export-setup" class="space-y-5">
        <div class="flex justify-between items-center">
            <h3 class="font-bold text-lg" data-i18n="export_header">Export-Eigenschaften</h3>
            <button onclick="toggleExportMenu()" class="text-slate-500 hover:text-white">&times;</button>
        </div>
        
        <!-- Formatwahl Buttons (A4, Frei) -->
        <div class="space-y-2">
            <label class="text-[10px] uppercase font-bold text-slate-500 tracking-wider" data-i18n="format_label">Format-Vorlage (Verhältnis)</label>
            <div class="grid grid-cols-3 gap-2">
                <button onclick="setExportFormat('free')" id="fmt-free" class="fmt-btn bg-white/10 p-2 rounded-xl text-[10px] font-bold border border-blue-400/50 text-blue-400 active" data-i18n="fmt_free">FREI</button>
                <button onclick="setExportFormat('a4l')" id="fmt-a4l" class="fmt-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10" data-i18n="fmt_a4l">DIN QUER</button>
                <button onclick="setExportFormat('a4p')" id="fmt-a4p" class="fmt-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10" data-i18n="fmt_a4p">DIN HOCH</button>
            </div>
        </div>

        <!-- Zoom Level Buttons -->
        <div class="space-y-2">
            <label class="text-[10px] uppercase font-bold text-slate-500 tracking-wider" data-i18n="zoom_label">Detail-Grad (Zoom)</label>
            <div class="grid grid-cols-4 gap-2">
                <button onclick="setExportZoom(15)" id="zoom-15" class="zoom-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10">Z15</button>
                <button onclick="setExportZoom(16)" id="zoom-16" class="zoom-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10">Z16</button>
                <button onclick="setExportZoom(17)" id="zoom-17" class="zoom-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10">Z17</button>
                <button onclick="setExportZoom(18)" id="zoom-18" class="zoom-btn bg-white/10 p-2 rounded-xl text-[10px] font-bold border border-blue-400/50 text-blue-400 active">Z18</button>
            </div>
        </div>

        <!-- Werkzeug zum Rechteck ziehen -->
        <button onclick="startSelection()" id="select-btn" class="w-full bg-slate-800 hover:bg-slate-700 py-3 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 border border-white/10">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122" /></svg>
            <span data-i18n="select_area_btn">Ausschnitt auf Karte wählen</span>
        </button>

        <div id="selection-info" class="hidden text-[11px] text-emerald-400 bg-emerald-400/10 p-2 rounded-lg text-center border border-emerald-400/20" data-i18n="area_fixed">
            Ausschnitt fixiert ✓
        </div>

        <!-- DER PNG BUTTON (Blau) -->
        <button id="png-btn" onclick="exportAsPNG()" class="w-full bg-blue-600 hover:bg-blue-500 disabled:opacity-30 disabled:cursor-not-allowed py-3 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 shadow-lg">
            <span data-i18n="png_btn">Hydrantenplan (PNG)</span>
        </button>

        <!-- DER GPX BUTTON (Grün) -->
        <button id="gpx-btn" onclick="exportAsGPX()" class="w-full bg-emerald-600 hover:bg-emerald-500 py-3 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 shadow-lg border border-emerald-400/30">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
            <span data-i18n="gpx_btn">Hydranten exportieren (GPX)</span>
        </button>
    </div>
    
    <!-- Ansicht B: Ladebalken (wird nur beim PNG-Export sichtbar) -->
    <div id="export-progress" class="hidden">
        <div class="flex justify-between items-center mb-4">
            <h3 class="font-bold text-lg exporting-active text-blue-400" data-i18n="exporting_title">Export wird erstellt...</h3>
        </div>
        <div class="space-y-4">
            <div>
                <div class="flex justify-between text-[10px] mb-1 uppercase tracking-widest text-blue-400 font-bold">
                    <span id="progress-label" data-i18n="loading_tiles">Lade Kacheln...</span>
                    <span id="progress-percent">0%</span>
                </div>
                <!-- Der Balken -->
                <div class="h-2 w-full bg-slate-800 rounded-full overflow-hidden">
                    <div id="progress-bar" class="h-full bg-blue-500 w-0 transition-all duration-300"></div>
                </div>
            </div>
            <button onclick="cancelExport()" class="w-full bg-red-500/10 hover:bg-red-500/20 text-red-400 py-2 rounded-xl text-sm font-semibold border border-red-500/20" data-i18n="cancel_btn">
                Vorgang abbrechen
            </button>
        </div>
    </div>
</div>

<!-- INFO BOX (Unten Rechts) -->
<div class="absolute bottom-10 right-10 z-[1000] glass-panel p-4 rounded-2xl text-[10px] text-slate-400 font-mono border border-white/5">
    <div class="flex justify-between gap-4"><span data-i18n="zoom_info">ZOOM</span><span id="zoom-val" class="text-white font-bold">14.0</span></div>
    <div class="flex justify-between gap-4"><span data-i18n="data_info">DATEN</span><span id="data-status" class="text-green-400">AKTUELL</span></div>
</div>

<!-- JAVASCRIPT LOGIK (DIE ELEKTRIK) -->
<script>
    /* =========================================================================
       0. WÖRTERBUCH (DICTIONARY)
       Hier sind alle Texte gespeichert. Das Programm sucht sich die passenden
       Texte basierend auf der Sprache des Benutzers heraus.
       ========================================================================= */
    const translations = {
        // Deutsch
        de: {
            search_placeholder: "Ort suchen...",
            locate_title: "Mein Standort",
            layers_title: "Karte wechseln",
            export_title: "Export",
            bg_header: "Hintergrund",
            layer_std: "Standard (Voyager)",
            layer_print: "Druck (Hell)",
            layer_night: "Nacht (Dunkel)",
            layer_sat: "Satellit (Esri)",
            layer_topo: "Topographisch (OSM)",
            layer_osm: "OSM (Intl)",
            layer_osmde: "OSM (DE Style)",
            export_header: "Export-Eigenschaften",
            format_label: "Format-Vorlage (Verhältnis)",
            fmt_free: "FREI",
            fmt_a4l: "DIN QUER",
            fmt_a4p: "DIN HOCH",
            zoom_label: "Detail-Grad (Zoom)",
            select_area_btn: "Ausschnitt auf Karte wählen",
            area_fixed: "Ausschnitt fixiert ✓",
            png_btn: "Hydrantenplan (PNG)",
            gpx_btn: "Hydranten exportieren (GPX)",
            exporting_title: "Export wird erstellt...",
            loading_tiles: "Lade Kacheln...",
            cancel_btn: "Vorgang abbrechen",
            zoom_info: "ZOOM",
            data_info: "DATEN",
            status_current: "AKTUELL",
            status_loading: "LÄDT...",
            status_standby: "STANDBY (Zoom < 12)",
            status_error: "FEHLER",
            geo_error: "Geolokalisierung nicht unterstützt.",
            geo_found: "Standort gefunden!",
            geo_fail: "Standort fehlerhaft.",
            drag_area: "Bereich ziehen",
            no_objects: "Keine Objekte im gewählten Bereich!",
            gpx_success: "Objekte als GPX exportiert!",
            too_large: "Ausschnitt zu groß!",
            locating: "Lokalisiere Gebiet...",
            render_bounds: "Rendere Grenzen...",
            render_infra: "Rendere Infrastruktur...",
            layout_final: "Finalisiere Layout...",
            plan_title: "Orts- und Hydrantenplan",
            legend_date: "Stand",
            legend_res: "Auflösung",
            details: "Details",
            station: "Feuerwache",
            hydrant: "Hydrant",
            defib: "Defibrillator (AED)"
        },
        // Englisch (Fallback für alle anderen Sprachen)
        en: {
            search_placeholder: "Search location...",
            locate_title: "My Location",
            layers_title: "Switch Map Layer",
            export_title: "Export",
            bg_header: "Background",
            layer_std: "Standard (Voyager)",
            layer_print: "Print (Light)",
            layer_night: "Night (Dark)",
            layer_sat: "Satellite (Esri)",
            layer_topo: "Topographic (OSM)",
            layer_osm: "OSM (Intl)",
            layer_osmde: "OSM (DE Style)",
            export_header: "Export Properties",
            format_label: "Aspect Ratio",
            fmt_free: "FREE",
            fmt_a4l: "A4 LANDSCAPE",
            fmt_a4p: "A4 PORTRAIT",
            zoom_label: "Detail Level (Zoom)",
            select_area_btn: "Select Area on Map",
            area_fixed: "Area fixed ✓",
            png_btn: "Hydrant Map (PNG)",
            gpx_btn: "Export Hydrants (GPX)",
            exporting_title: "Creating Export...",
            loading_tiles: "Loading Tiles...",
            cancel_btn: "Cancel Process",
            zoom_info: "ZOOM",
            data_info: "DATA",
            status_current: "CURRENT",
            status_loading: "LOADING...",
            status_standby: "STANDBY (Zoom < 12)",
            status_error: "ERROR",
            geo_error: "Geolocation not supported.",
            geo_found: "Location found!",
            geo_fail: "Location failed.",
            drag_area: "Draw area",
            no_objects: "No objects in selected area!",
            gpx_success: "Objects exported as GPX!",
            too_large: "Area too large!",
            locating: "Locating area...",
            render_bounds: "Rendering boundaries...",
            render_infra: "Rendering infrastructure...",
            layout_final: "Finalizing layout...",
            plan_title: "Hydrant Map",
            legend_date: "Date",
            legend_res: "Resolution",
            details: "Details",
            station: "Fire Station",
            hydrant: "Hydrant",
            defib: "Defibrillator (AED)"
        },
        // Französisch
        fr: {
            search_placeholder: "Rechercher...",
            locate_title: "Ma position",
            layers_title: "Changer de carte",
            export_title: "Exporter",
            bg_header: "Arrière-plan",
            layer_std: "Standard (Voyager)",
            layer_print: "Impression (Clair)",
            layer_night: "Nuit (Sombre)",
            layer_sat: "Satellite (Esri)",
            layer_topo: "Topographique (OSM)",
            layer_osm: "OSM (Intl)",
            layer_osmde: "OSM (Style DE)",
            export_header: "Propriétés d'exportation",
            format_label: "Format (Ratio)",
            fmt_free: "LIBRE",
            fmt_a4l: "A4 PAYSAGE",
            fmt_a4p: "A4 PORTRAIT",
            zoom_label: "Niveau de détail (Zoom)",
            select_area_btn: "Sélectionner une zone",
            area_fixed: "Zone fixée ✓",
            png_btn: "Carte des poteaux (PNG)",
            gpx_btn: "Exporter en GPX",
            exporting_title: "Création de l'export...",
            loading_tiles: "Chargement des tuiles...",
            cancel_btn: "Annuler",
            zoom_info: "ZOOM",
            data_info: "DONNÉES",
            status_current: "ACTUEL",
            status_loading: "CHARGEMENT...",
            status_standby: "VEILLE (Zoom < 12)",
            status_error: "ERREUR",
            geo_error: "Géolocalisation non supportée.",
            geo_found: "Position trouvée !",
            geo_fail: "Échec de localisation.",
            drag_area: "Dessiner la zone",
            no_objects: "Aucun objet dans la zone !",
            gpx_success: "Objets exportés en GPX !",
            too_large: "Zone trop grande !",
            locating: "Localisation de la zone...",
            render_bounds: "Rendu des limites...",
            render_infra: "Rendu de l'infrastructure...",
            layout_final: "Finalisation...",
            plan_title: "Carte des Hydrants",
            legend_date: "Date",
            legend_res: "Résolution",
            details: "Détails",
            station: "Caserne",
            hydrant: "Poteau incendie",
            defib: "Défibrillateur (DAE)"
        },
        // Spanisch
        es: {
            search_placeholder: "Buscar lugar...",
            locate_title: "Mi ubicación",
            layers_title: "Cambiar mapa",
            export_title: "Exportar",
            bg_header: "Fondo",
            layer_std: "Estándar (Voyager)",
            layer_print: "Impresión (Claro)",
            layer_night: "Noche (Oscuro)",
            layer_sat: "Satélite (Esri)",
            layer_topo: "Topográfico (OSM)",
            layer_osm: "OSM (Intl)",
            layer_osmde: "OSM (Estilo DE)",
            export_header: "Propiedades de exportación",
            format_label: "Formato (Relación)",
            fmt_free: "LIBRE",
            fmt_a4l: "A4 PAISAJE",
            fmt_a4p: "A4 RETRATO",
            zoom_label: "Nivel de detalle (Zoom)",
            select_area_btn: "Seleccionar zona",
            area_fixed: "Zona fijada ✓",
            png_btn: "Mapa de hidrantes (PNG)",
            gpx_btn: "Exportar como GPX",
            exporting_title: "Creando exportación...",
            loading_tiles: "Cargando teselas...",
            cancel_btn: "Cancelar",
            zoom_info: "ZOOM",
            data_info: "DATOS",
            status_current: "ACTUAL",
            status_loading: "CARGANDO...",
            status_standby: "ESPERA (Zoom < 12)",
            status_error: "ERROR",
            geo_error: "Geolocalización no soportada.",
            geo_found: "¡Ubicación encontrada!",
            geo_fail: "Fallo de ubicación.",
            drag_area: "Arrastrar área",
            no_objects: "¡No hay objetos en la zona!",
            gpx_success: "¡Objetos exportados a GPX!",
            too_large: "¡Zona demasiado grande!",
            locating: "Localizando zona...",
            render_bounds: "Renderizando límites...",
            render_infra: "Renderizando infraestructura...",
            layout_final: "Finalizando diseño...",
            plan_title: "Mapa de Hidrantes",
            legend_date: "Fecha",
            legend_res: "Resolución",
            details: "Detalles",
            station: "Estación de bomberos",
            hydrant: "Hidrante",
            defib: "Desfibrilador (DEA)"
        },
        // Italienisch
        it: {
            search_placeholder: "Cerca luogo...",
            locate_title: "La mia posizione",
            layers_title: "Cambia mappa",
            export_title: "Esporta",
            bg_header: "Sfondo",
            layer_std: "Standard (Voyager)",
            layer_print: "Stampa (Chiaro)",
            layer_night: "Notte (Scuro)",
            layer_sat: "Satellite (Esri)",
            layer_topo: "Topografico (OSM)",
            layer_osm: "OSM (Intl)",
            layer_osmde: "OSM (Stile DE)",
            export_header: "Proprietà esportazione",
            format_label: "Formato",
            fmt_free: "LIBERO",
            fmt_a4l: "A4 ORIZZONTALE",
            fmt_a4p: "A4 VERTICALE",
            zoom_label: "Dettaglio (Zoom)",
            select_area_btn: "Seleziona area",
            area_fixed: "Area fissata ✓",
            png_btn: "Mappa idranti (PNG)",
            gpx_btn: "Esporta in GPX",
            exporting_title: "Creazione esportazione...",
            loading_tiles: "Caricamento riquadri...",
            cancel_btn: "Annulla",
            zoom_info: "ZOOM",
            data_info: "DATI",
            status_current: "ATTUALE",
            status_loading: "CARICAMENTO...",
            status_standby: "STANDBY (Zoom < 12)",
            status_error: "ERRORE",
            geo_error: "Geolocalizzazione non supportata.",
            geo_found: "Posizione trovata!",
            geo_fail: "Posizione fallita.",
            drag_area: "Disegna area",
            no_objects: "Nessun oggetto nell'area!",
            gpx_success: "Oggetti esportati in GPX!",
            too_large: "Area troppo grande!",
            locating: "Localizzazione area...",
            render_bounds: "Rendering confini...",
            render_infra: "Rendering infrastruttura...",
            layout_final: "Finalizzazione layout...",
            plan_title: "Mappa Idranti",
            legend_date: "Data",
            legend_res: "Risoluzione",
            details: "Dettagli",
            station: "Caserma pompieri",
            hydrant: "Idrante",
            defib: "Defibrillatore (DAE)"
        },
        // Polnisch
        pl: {
            search_placeholder: "Szukaj miejsca...",
            locate_title: "Moja lokalizacja",
            layers_title: "Zmień mapę",
            export_title: "Eksport",
            bg_header: "Tło",
            layer_std: "Standard (Voyager)",
            layer_print: "Druk (Jasny)",
            layer_night: "Noc (Ciemny)",
            layer_sat: "Satelita (Esri)",
            layer_topo: "Topograficzna (OSM)",
            layer_osm: "OSM (Intl)",
            layer_osmde: "OSM (Styl DE)",
            export_header: "Właściwości eksportu",
            format_label: "Format",
            fmt_free: "WOLNY",
            fmt_a4l: "A4 POZIOMO",
            fmt_a4p: "A4 PIONOWO",
            zoom_label: "Poziom szczegółów (Zoom)",
            select_area_btn: "Wybierz obszar",
            area_fixed: "Obszar ustalony ✓",
            png_btn: "Mapa hydrantów (PNG)",
            gpx_btn: "Eksportuj do GPX",
            exporting_title: "Tworzenie eksportu...",
            loading_tiles: "Ładowanie kafelków...",
            cancel_btn: "Anuluj",
            zoom_info: "ZOOM",
            data_info: "DANE",
            status_current: "AKTUALNE",
            status_loading: "ŁADOWANIE...",
            status_standby: "CZUWANIE (Zoom < 12)",
            status_error: "BŁĄD",
            geo_error: "Geolokalizacja nieobsługiwana.",
            geo_found: "Znaleziono lokalizację!",
            geo_fail: "Błąd lokalizacji.",
            drag_area: "Rysuj obszar",
            no_objects: "Brak obiektów w obszarze!",
            gpx_success: "Wyeksportowano do GPX!",
            too_large: "Obszar zbyt duży!",
            locating: "Lokalizowanie obszaru...",
            render_bounds: "Renderowanie granic...",
            render_infra: "Renderowanie infrastruktury...",
            layout_final: "Finalizowanie układu...",
            plan_title: "Mapa Hydrantów",
            legend_date: "Data",
            legend_res: "Rozdzielczość",
            details: "Szczegóły",
            station: "Straż pożarna",
            hydrant: "Hydrant",
            defib: "Defibrylator (AED)"
        },
        // Niederländisch
        nl: {
            search_placeholder: "Zoek locatie...",
            locate_title: "Mijn locatie",
            layers_title: "Kaart wisselen",
            export_title: "Export",
            bg_header: "Achtergrond",
            layer_std: "Standaard (Voyager)",
            layer_print: "Print (Licht)",
            layer_night: "Nacht (Donker)",
            layer_sat: "Satelliet (Esri)",
            layer_topo: "Topografisch (OSM)",
            layer_osm: "OSM (Intl)",
            layer_osmde: "OSM (DE Stijl)",
            export_header: "Export Eigenschappen",
            format_label: "Formaat",
            fmt_free: "VRIJ",
            fmt_a4l: "A4 LIGGEND",
            fmt_a4p: "A4 STAAND",
            zoom_label: "Detailniveau (Zoom)",
            select_area_btn: "Selecteer gebied",
            area_fixed: "Gebied vastgelegd ✓",
            png_btn: "Hydrantenkaart (PNG)",
            gpx_btn: "Exporteer naar GPX",
            exporting_title: "Export maken...",
            loading_tiles: "Tegels laden...",
            cancel_btn: "Annuleren",
            zoom_info: "ZOOM",
            data_info: "DATA",
            status_current: "ACTUEEL",
            status_loading: "LADEN...",
            status_standby: "STANDBY (Zoom < 12)",
            status_error: "FOUT",
            geo_error: "Geolocatie niet ondersteund.",
            geo_found: "Locatie gevonden!",
            geo_fail: "Locatie mislukt.",
            drag_area: "Sleep gebied",
            no_objects: "Geen objecten in gebied!",
            gpx_success: "Geëxporteerd als GPX!",
            too_large: "Gebied te groot!",
            locating: "Gebied lokaliseren...",
            render_bounds: "Grenzen renderen...",
            render_infra: "Infrastructuur renderen...",
            layout_final: "Lay-out voltooien...",
            plan_title: "Hydrantenkaart",
            legend_date: "Datum",
            legend_res: "Resolutie",
            details: "Details",
            station: "Brandweerkazerne",
            hydrant: "Brandkraan",
            defib: "Defibrillator (AED)"
        },
        // Tschechisch
        cs: {
            search_placeholder: "Hledat místo...",
            locate_title: "Moje poloha",
            layers_title: "Změnit mapu",
            export_title: "Export",
            bg_header: "Pozadí",
            layer_std: "Standard (Voyager)",
            layer_print: "Tisk (Světlý)",
            layer_night: "Noc (Tmavý)",
            layer_sat: "Satelit (Esri)",
            layer_topo: "Topografická (OSM)",
            layer_osm: "OSM (Intl)",
            layer_osmde: "OSM (DE Styl)",
            export_header: "Vlastnosti exportu",
            format_label: "Formát",
            fmt_free: "VOLNÝ",
            fmt_a4l: "A4 NA ŠÍŘKU",
            fmt_a4p: "A4 NA VÝŠKU",
            zoom_label: "Úroveň detailů (Zoom)",
            select_area_btn: "Vybrat oblast",
            area_fixed: "Oblast fixována ✓",
            png_btn: "Mapa hydrantů (PNG)",
            gpx_btn: "Exportovat do GPX",
            exporting_title: "Vytváření exportu...",
            loading_tiles: "Načítání dlaždic...",
            cancel_btn: "Zrušit",
            zoom_info: "ZOOM",
            data_info: "DATA",
            status_current: "AKTUÁLNÍ",
            status_loading: "NAČÍTÁNÍ...",
            status_standby: "PŘIPRAVENO (Zoom < 12)",
            status_error: "CHYBA",
            geo_error: "Geolokace není podporována.",
            geo_found: "Poloha nalezena!",
            geo_fail: "Poloha nezjištěna.",
            drag_area: "Vybrat oblast",
            no_objects: "Žádné objekty v oblasti!",
            gpx_success: "Exportováno do GPX!",
            too_large: "Oblast je příliš velká!",
            locating: "Lokalizace oblasti...",
            render_bounds: "Vykreslování hranic...",
            render_infra: "Vykreslování infrastruktury...",
            layout_final: "Dokončování...",
            plan_title: "Mapa Hydrantů",
            legend_date: "Datum",
            legend_res: "Rozlišení",
            details: "Podrobnosti",
            station: "Hasičská stanice",
            hydrant: "Hydrant",
            defib: "Defibrilátor (AED)"
        }
    };

    /* =========================================================================
       1. SPRACH-LOGIK & HAUPT-VARIABLEN
       Das Herzstück der internationalen Version.
       ========================================================================= */
    
    // Schritt 1: Wir schauen, welche Sprache der Browser benutzt.
    // Das ist z.B. "de-DE" für Deutsch-Deutschland oder "fr-CA" für Französisch-Kanada.
    const userLangFull = navigator.language || navigator.userLanguage; 
    
    // Schritt 2: Wir schneiden alles nach dem Bindestrich ab. Wir wollen nur "de", "fr", "en".
    const userLangShort = userLangFull.split('-')[0];
    
    // Schritt 3: Wir prüfen: Kennen wir diese Sprache?
    // Wenn 'translations' einen Eintrag für 'fr' hat, nehmen wir 'fr'.
    // Wenn nicht (z.B. bei Japanisch 'ja'), nehmen wir Englisch ('en') als Standard.
    const currentLang = translations[userLangShort] ? userLangShort : 'en';
    
    // Das ist unsere Übersetzungs-Maschine:
    // Du gibst ihr einen Schlüssel (z.B. "png_btn") und sie gibt den richtigen Text zurück.
    function t(key) {
        return translations[currentLang][key] || translations['en'][key] || key;
    }

    // Diese Funktion läuft einmal beim Starten. Sie sucht alle Texte auf der Seite und tauscht sie aus.
    function updatePageLanguage() {
        console.log(`Sprache erkannt: ${userLangFull} -> Nutze: ${currentLang}`); // Nur für Entwickler in der Konsole
        
        // 1. Normale Texte (z.B. in Buttons oder Überschriften)
        // Wir suchen alles, was das Attribut 'data-i18n' hat.
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n'); // Welcher Textschlüssel?
            el.innerText = t(key); // Ersetze den Inhalt durch die Übersetzung
        });
        
        // 2. Tooltips (Mouseover-Texte)
        // Wir suchen alles mit 'data-i18n-title'.
        document.querySelectorAll('[data-i18n-title]').forEach(el => {
            const key = el.getAttribute('data-i18n-title');
            el.title = t(key);
        });
        
        // 3. Platzhalter in Eingabefeldern (z.B. "Ort suchen...")
        // Wir suchen alles mit 'data-i18n-placeholder'.
        document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
            const key = el.getAttribute('data-i18n-placeholder');
            el.placeholder = t(key);
        });
    }

    /* ----------------------------------------------------------- */
    /* HIER BEGINNEN DIE NORMALEN KARTEN-VARIABLEN */

    let map;                    // Die Karte selbst
    let markerLayer;            // Folie für Hydranten
    let boundaryLayer;          // Folie für Grenzen
    let rangeLayerGroup;        // Folie für den 100m Kreis
    let activeRangeCenter = null; // Welcher Hydrant ist gerade angeklickt?
    let currentRequestController; // Hilft beim Abbrechen alter Internet-Anfragen
    let exportAbortController;    // Hilft beim Abbrechen des Exports
    let cachedElements = [];    // Unser Gedächtnis: Hier liegen alle heruntergeladenen Hydranten
    let activeLayerConfig = 'voyager'; // Welches Karten-Design ist aktiv?
    let exportFormat = 'free';  // Welches Papierformat?
    let exportZoomLevel = 18;   // Wie scharf soll das Bild sein?
    let isSelecting = false, selectionRect = null, startPoint = null, finalBounds = null; // Variablen für das Rechteck-Werkzeug

    // Woher kommen die Bilder für den Hintergrund? (URLs der Server)
    const layerUrls = {
        voyager: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
        positron: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
        dark: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
        satellite: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        topo: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
        osm: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        osmde: 'https://{s}.tile.openstreetmap.de/{z}/{x}/{y}.png'
    };

    // Maximale Zoomstufe pro Karte (manche Karten werden unscharf, wenn man zu nah ran geht)
    const layerMaxZoom = { voyager: 18, positron: 18, dark: 18, satellite: 18, topo: 16, osm: 18, osmde: 18 };
    // Wo fragen wir die Hydranten ab? (Overpass API Server)
    const overpassEndpoints = ['https://overpass-api.de/api/interpreter', 'https://overpass.kumi.systems/api/interpreter'];

    /* =========================================================================
       2. KARTEN START & WERKZEUGE
       ========================================================================= */
    
    // Zeigt rote Nachrichten oben rechts an
    function showNotification(msg) {
        const box = document.getElementById('notification-box');
        if (!box) return;
        box.innerText = msg;
        box.style.display = 'block';
        setTimeout(() => box.style.display = 'none', 3000); // Verschwindet nach 3 Sekunden
    }

    // Die Haupt-Start-Funktion
    function initMap() {
        // ZUERST: Sprache einstellen!
        updatePageLanguage();

        // Layer-Gruppen erstellen
        markerLayer = L.layerGroup();
        boundaryLayer = L.layerGroup(); 
        rangeLayerGroup = L.layerGroup(); 
        
        // Karte erstellen, Startpunkt: Schnaittach
        map = L.map('map', { zoomControl: false, center: [49.555, 11.350], zoom: 14 });
        
        setBaseLayer('voyager'); 
        boundaryLayer.addTo(map); 
        rangeLayerGroup.addTo(map); 
        markerLayer.addTo(map);   
        
        // Wenn man die Karte bewegt -> Neue Daten laden
        map.on('moveend zoomend', fetchOSMData); 
        // Wenn man zoomt -> Kreis aktualisieren
        map.on('zoomend', updateRangeCircle);    
        // Zoom-Anzeige unten rechts aktualisieren
        map.on('zoom', () => document.getElementById('zoom-val').innerText = map.getZoom().toFixed(1)); 
        
        // Maus-Events für das Rechteck-Ziehen
        map.on('mousedown', onMouseDown);
        map.on('mousemove', onMouseMove);
        map.on('mouseup', onMouseUp);
        
        // Klick ins Leere -> Auswahl aufheben
        map.on('click', () => {
            if (activeRangeCenter && !isSelecting) {
                activeRangeCenter = null;
                updateRangeCircle();
            }
        });

        // Daten jetzt laden
        fetchOSMData();
    }

    /* =========================================================================
       3. DATEN LADEN (Die Overpass API Logik)
       ========================================================================= */
    
    // Hilfsfunktion: Versucht Server A, wenn kaputt, dann Server B
    async function fetchWithRetry(query) {
        for (let endpoint of overpassEndpoints) {
            try {
                const res = await fetch(`${endpoint}?data=${encodeURIComponent(query)}`, { signal: currentRequestController.signal });
                if (!res.ok) continue; 
                const text = await res.text();
                // Check ob Antwort valide ist
                if (text.trim().startsWith('<?xml') || text.trim().startsWith('<html')) continue;
                return JSON.parse(text); 
            } catch (e) { if (e.name === 'AbortError') throw e; } 
        }
        throw new Error("API Fehler");
    }

    // Entscheidet, WELCHE Daten geladen werden (Optimierung!)
    async function fetchOSMData() {
        const zoom = map.getZoom();
        
        // Regel: Unter Zoom 12 laden wir gar nichts (zu viele Daten)
        if (zoom < 12) {
            document.getElementById('data-status').innerText = t('status_standby'); 
            cachedElements = [];
            markerLayer.clearLayers();
            boundaryLayer.clearLayers();
            return; 
        }
        
        // Wir schauen, wo wir gerade auf der Karte sind (Koordinaten)
        const b = map.getBounds();
        const bbox = `${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()}`;
        
        const status = document.getElementById('data-status');
        status.innerText = t('status_loading'); 
        
        if (currentRequestController) currentRequestController.abort();
        currentRequestController = new AbortController();
        
        // Wir bauen die Datenbank-Abfrage zusammen
        let queryParts = [];
        
        // Ab Zoom 12: Wachen laden
        if (zoom >= 12) {
            queryParts.push(`nwr["amenity"="fire_station"](${bbox});`);
            queryParts.push(`nwr["building"="fire_station"](${bbox});`);
        }
        // Erst ab Zoom 15: Hydranten laden (weil es so viele sind)
        if (zoom >= 15) {
            queryParts.push(`nwr["emergency"~"fire_hydrant|water_tank|suction_point|fire_water_pond|cistern"](${bbox});`);
        }

        // Ab Zoom 16: Defibrillatoren laden (Update)
        if (zoom >= 16) {
            queryParts.push(`node["emergency"="defibrillator"](${bbox});`);
        }

        // Ab Zoom 14: Gemeindegrenzen laden
        let boundaryQuery = '';
        if (zoom >= 14) {
            boundaryQuery = `(way["boundary"="administrative"]["admin_level"="8"](${bbox});)->.boundaries; .boundaries out geom;`;
        }

        if (queryParts.length === 0 && boundaryQuery === '') return;

        // Der finale Code für den Server
        let q = `[out:json][timeout:90];
        (
          ${queryParts.join('\n')}
        )->.pois;
        .pois out center;
        ${boundaryQuery}`;
        
        try {
            const data = await fetchWithRetry(q);
            cachedElements = data.elements; // Daten merken
            renderMarkers(data.elements, zoom); // Malen
            status.innerText = t('status_current'); 
        } catch (e) { if (e.name !== 'AbortError') status.innerText = t('status_error'); }
    }

    /* =========================================================================
       4. DARSTELLUNG (Marker malen)
       ========================================================================= */
    
    // Baut das kleine Bildchen (SVG) für die Karte
    function getSVGContent(type) {
        // Spezialfall Defibrillator (Grün mit Herz)
        if (type === 'defibrillator') {
             return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <circle cx="50" cy="50" r="45" fill="#16a34a" stroke="white" stroke-width="5"/>
                <path d="M50 80 C10 40 10 10 50 35 C90 10 90 40 50 80 Z" fill="white"/>
                <path d="M55 45 L45 55 L55 55 L45 65" stroke="#16a34a" stroke-width="3" fill="none"/>
            </svg>`;
        }

        const isWater = ['water_tank', 'cistern', 'fire_water_pond', 'suction_point'].includes(type);
        const color = isWater ? '#3b82f6' : '#ef4444'; // Blau oder Rot
        
        // Spezialfall Wandhydrant
        if (type === 'wall') {
             return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <circle cx="50" cy="50" r="45" fill="${color}" stroke="white" stroke-width="5"/>
                <circle cx="42" cy="52" r="18" fill="none" stroke="white" stroke-width="6" />
                <line x1="64" y1="34" x2="64" y2="70" stroke="white" stroke-width="6" stroke-linecap="round" />
            </svg>`;
        }
        
        // Buchstaben zuweisen
        let char = '';
        switch(type) {
            case 'underground': char = 'U'; break; 
            case 'pillar':      char = 'O'; break; 
            case 'pipe':        char = 'I'; break;
            case 'dry_barrel':  char = 'Ø'; break; 
            default:            char = '';
        }
        
        // Feuerwache Icon
        if (type === 'station') return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M10 40 L50 5 L90 40 L90 90 L10 90 Z" fill="#ef4444" stroke="white" stroke-width="4"/><rect x="30" y="55" width="40" height="35" rx="2" fill="white" opacity="0.9"/></svg>`;
        
        // Normales Hydranten Icon
        return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="45" fill="${color}" stroke="white" stroke-width="5"/>${char ? `<text x="50" y="72" font-family="Arial" font-weight="bold" font-size="50" text-anchor="middle" fill="white">${char}</text>` : ''}</svg>`;
    }

    // Malt die Marker auf die Karte
    function renderMarkers(elements, zoom) {
        markerLayer.clearLayers(); 
        boundaryLayer.clearLayers(); 
        const renderedLocations = []; 
        
        elements.forEach(el => {
            const tags = el.tags || {};
            // Grenzen malen
            if (tags.boundary === 'administrative' && el.geometry) {
                if (zoom < 14) return; 
                const latlngs = el.geometry.map(p => [p.lat, p.lon]);
                L.polyline(latlngs, { color: '#333333', weight: 1, dashArray: '10, 10', opacity: 0.7 }).addTo(boundaryLayer);
                return; 
            }
            // Position finden
            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            if (!lat || !lon) return;

            const isStation = tags.amenity === 'fire_station' || tags.building === 'fire_station';
            const isDefib = tags.emergency === 'defibrillator';
            let type = '';

            if (isStation) type = 'station';
            else if (isDefib) type = 'defibrillator';
            else type = tags['fire_hydrant:type'] || tags.emergency;

            // Filter
            if (isStation && zoom < 12) return; 
            if (!isStation && !isDefib && zoom < 15) return; 
            // Defibrillatoren NUR ab Zoom 16
            if (isDefib && zoom < 16) return;

            // Überlappungsschutz (damit nicht 2 Marker genau übereinander liegen)
            const alreadyDrawn = renderedLocations.some(loc => Math.abs(loc.lat - lat) < 0.0001 && Math.abs(loc.lon - lon) < 0.0001);
            if (isStation && alreadyDrawn) return;
            if (isStation) renderedLocations.push({lat, lon});

            if (isStation) {
                if (zoom < 14) {
                     // Kleines Quadrat bei weitem Zoom
                     L.marker([lat, lon], { icon: L.divIcon({ html: '<div class="station-square"></div>', iconSize: [10,10] }) }).addTo(markerLayer);
                } else {
                     // Großes Icon wenn nah dran
                     const iconHtml = getSVGContent(type);
                     const marker = L.marker([lat, lon], { icon: L.divIcon({ className: 'icon-container', html: iconHtml, iconSize: [32, 32] }), zIndexOffset: 1000 }).addTo(markerLayer);
                    if (zoom === 18) { marker.bindTooltip(generateTooltip(tags), { sticky: true, opacity: 0.95 }); }
                }
            } else if (isDefib) {
                if (zoom < 17) {
                    // Zoom 16: Grüner Punkt
                    L.marker([lat, lon], { icon: L.divIcon({ className: 'defib-dot', iconSize: [10,10] }) }).addTo(markerLayer);
                } else {
                    // Ab Zoom 17: Defib Icon
                    const iconHtml = getSVGContent(type);
                    const marker = L.marker([lat, lon], { icon: L.divIcon({ className: 'icon-container', html: iconHtml, iconSize: [28, 28] }), zIndexOffset: 2000 }).addTo(markerLayer);
                    // Tooltip NUR bei Zoom 18
                    if (zoom === 18) {
                        marker.bindTooltip(generateTooltip(tags), { sticky: true, opacity: 0.95 });
                    }
                }
            } else {
                if (zoom < 17) {
                    // Kleiner Punkt bei mittlerem Zoom
                    const color = ['water_tank', 'cistern', 'fire_water_pond', 'suction_point'].includes(type) ? 'tank-dot' : 'hydrant-dot';
                    L.marker([lat, lon], { icon: L.divIcon({ className: color, iconSize: [10,10] }) }).addTo(markerLayer);
                } else {
                    // Großes Icon bei sehr nahem Zoom
                    const iconHtml = getSVGContent(type);
                    const marker = L.marker([lat, lon], { icon: L.divIcon({ className: 'icon-container', html: iconHtml, iconSize: [28, 28] }), zIndexOffset: 0 }).addTo(markerLayer);
                    if (zoom === 18) { marker.bindTooltip(generateTooltip(tags), { sticky: true, opacity: 0.95 }); }
                    // Klick-Event für 100m Kreis
                    marker.on('click', (e) => { L.DomEvent.stopPropagation(e); showRangeCircle(lat, lon); });
                }
            }
        });
    }

    // Baut das Info-Fenster (Tooltip)
    function generateTooltip(tags) {
        let tooltipTitle = tags.name || t('details');
        if (tags.emergency === 'defibrillator') tooltipTitle = t('defib');

        let html = `<div class="p-2 min-w-[180px]">
            <div class="font-bold text-sm border-b border-white/20 pb-1 mb-1 text-blue-400">${tooltipTitle}</div>
            <div class="text-[10px] font-mono grid grid-cols-[auto_1fr] gap-x-2 gap-y-1">`;
        for (const [key, val] of Object.entries(tags)) {
            html += `<div class="text-slate-400 text-right">${key}:</div><div class="text-slate-200 break-words">${val}</div>`;
        }
        html += `</div></div>`;
        return html;
    }

    function showRangeCircle(lat, lon) {
        activeRangeCenter = {lat, lon};
        updateRangeCircle();
    }

    // Malt den orangenen Kreis
    function updateRangeCircle() {
        rangeLayerGroup.clearLayers();
        if (!activeRangeCenter) return;
        const zoom = map.getZoom();
        if (zoom < 16) return; 

        L.circle([activeRangeCenter.lat, activeRangeCenter.lon], {
            color: '#f97316', fillColor: '#f97316', fillOpacity: 0.15, radius: 100, weight: 2, dashArray: '5, 8', interactive: false 
        }).addTo(rangeLayerGroup);

        if (zoom >= 17) {
            // Berechnung für die Position des "100m" Textes
            const latRad = activeRangeCenter.lat * Math.PI / 180;
            const kmPerDegLon = 111.32 * Math.cos(latRad);
            const offsetLon = 0.05 / kmPerDegLon; 
            const labelPos = [activeRangeCenter.lat, activeRangeCenter.lon + offsetLon];
            const labelMarker = L.marker(labelPos, {opacity: 0, interactive: false}).addTo(rangeLayerGroup);
            labelMarker.bindTooltip("100 m", { permanent: true, direction: 'center', className: 'range-label', offset: [0, 0] }).openTooltip();
        }
    }

    // Findet die GPS Position des Nutzers
    function locateUser() {
        if (!navigator.geolocation) { showNotification(t('geo_error')); return; }
        const btn = document.getElementById('locate-btn');
        const icon = btn ? btn.querySelector('svg') : null;
        if(icon) icon.classList.add('animate-spin'); 

        navigator.geolocation.getCurrentPosition(
            (pos) => {
                const { latitude, longitude } = pos.coords;
                map.flyTo([latitude, longitude], 18, { animate: true, duration: 1.5 });
                if(icon) icon.classList.remove('animate-spin');
                showNotification(t('geo_found'));
            },
            (err) => {
                console.warn("Geolocation Fehler:", err);
                if(icon) icon.classList.remove('animate-spin');
                showNotification(t('geo_fail'));
            },
            { enableHighAccuracy: true, timeout: 5000 }
        );
    }

    /* =========================================================================
       5. EXPORT & MENÜ FUNKTIONEN
       ========================================================================= */
    function setExportFormat(fmt) {
        exportFormat = fmt;
        // Buttons visuell umschalten
        document.querySelectorAll('.fmt-btn').forEach(b => {
            b.classList.remove('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
            b.classList.add('bg-white/5');
        });
        document.getElementById(`fmt-${fmt}`).classList.add('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
        clearSelection(); 
    }

    function setExportZoom(z) {
        if (activeLayerConfig === 'topo' && z > 17) return; 
        exportZoomLevel = z;
        document.querySelectorAll('.zoom-btn').forEach(b => {
            b.classList.remove('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
            b.classList.add('bg-white/5');
        });
        const activeBtn = document.getElementById(`zoom-${z}`);
        if(activeBtn) {
            activeBtn.classList.add('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
            activeBtn.classList.remove('bg-white/5');
        }
    }

    function startSelection() {
        isSelecting = true;
        clearSelection();
        map.dragging.disable(); 
        map.getContainer().classList.add('selection-mode'); 
        showNotification(t('drag_area')); 
    }

    function clearSelection() {
        if (selectionRect) { map.removeLayer(selectionRect); selectionRect = null; }
        finalBounds = null;
        document.getElementById('selection-info').classList.add('hidden');
    }

    // Rechteck ziehen: Maus gedrückt
    function onMouseDown(e) {
        if (!isSelecting) return;
        startPoint = e.latlng;
        selectionRect = L.rectangle([startPoint, startPoint], {
            color: '#3b82f6', weight: 2, fillOpacity: 0.2, interactive: false
        }).addTo(map);
    }

    // Rechteck ziehen: Maus bewegen
    function onMouseMove(e) {
        if (!isSelecting || !startPoint || !selectionRect) return;
        let current = e.latlng;
        if (exportFormat !== 'free') {
            // Seitenverhältnis erzwingen
            const ratio = (exportFormat === 'a4l') ? 1.4142 : 0.7071; 
            const lngScale = Math.cos(startPoint.lat * Math.PI / 180);
            const dy = Math.abs(current.lat - startPoint.lat);
            const dx = (dy * ratio) / lngScale;
            const latDir = current.lat > startPoint.lat ? 1 : -1;
            const lngDir = current.lng > startPoint.lng ? 1 : -1;
            current = L.latLng(startPoint.lat + (latDir * dy), startPoint.lng + (lngDir * dx));
        }
        selectionRect.setBounds([startPoint, current]);
    }

    // Rechteck ziehen: Maus loslassen
    function onMouseUp(e) {
        if (!isSelecting || !startPoint) return;
        finalBounds = selectionRect.getBounds(); 
        isSelecting = false; startPoint = null;
        map.dragging.enable(); 
        map.getContainer().classList.remove('selection-mode');
        document.getElementById('selection-info').classList.remove('hidden');
    }

    function setBaseLayer(key) {
        activeLayerConfig = key;
        map.eachLayer(layer => { if (layer instanceof L.TileLayer) map.removeLayer(layer); });
        L.tileLayer(layerUrls[key], { attribution: '&copy; OSM', crossOrigin: 'anonymous' }).addTo(map);
        document.querySelectorAll('.layer-btn').forEach(btn => btn.classList.remove('active'));
        const activeBtn = document.getElementById(`btn-${key}`);
        if(activeBtn) activeBtn.classList.add('active');
        const btn18 = document.getElementById('zoom-18');
        if (key === 'topo') {
            btn18.disabled = true;
            if (exportZoomLevel > 17) setExportZoom(17);
        } else {
            btn18.disabled = false;
        }
    }

    function toggleExportMenu() { document.getElementById('export-menu').classList.toggle('hidden'); resetExportUI(); }
    function toggleLayerMenu() { document.getElementById('layer-menu').classList.toggle('hidden'); }
    function resetExportUI() {
        document.getElementById('export-setup').classList.remove('hidden');
        document.getElementById('export-progress').classList.add('hidden');
        document.getElementById('progress-bar').style.width = '0%';
    }
    function cancelExport() { if(exportAbortController) exportAbortController.abort(); }

    function searchLocation() {
        const q = document.getElementById('search-input').value;
        if (!q) return;
        fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`).then(r => r.json()).then(d => { if(d.length) map.flyTo([d[0].lat, d[0].lon], 18); });
    }

    /* =========================================================================
       6. EXPORT FUNKTIONEN (GPX & PNG)
       ========================================================================= */
    
    // GPX Export: Schreibt eine Textdatei im XML-Format
    function exportAsGPX() {
        const bounds = finalBounds || map.getBounds();
        // Filtern: Nur Punkte im Bereich
        const pointsToExport = cachedElements.filter(el => {
            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            if (!lat || !lon) return false;
            return bounds.contains(L.latLng(lat, lon));
        });

        if (pointsToExport.length === 0) {
            showNotification(t('no_objects'));
            return;
        }

        // XML Datei aufbauen
        let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n';
        gpx += '<gpx version="1.1" creator="OpenFireMap V2" xmlns="http://www.topografix.com/GPX/1/1">\n';
        gpx += `  <metadata><name>Hydranten Export</name><time>${new Date().toISOString()}</time></metadata>\n`;

        pointsToExport.forEach(el => {
            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            const tags = el.tags || {};
            
            const isStation = tags.amenity === 'fire_station' || tags.building === 'fire_station';
            const isHydrant = tags.emergency && ['fire_hydrant', 'water_tank', 'suction_point', 'fire_water_pond', 'cistern'].some(t => tags.emergency.includes(t));
            const isDefib = tags.emergency === 'defibrillator';

            if (!isStation && !isHydrant && !isDefib) return;

            let name = tags.name || (isStation ? t('station') : (isDefib ? t('defib') : t('hydrant')));
            if (!tags.name && tags['fire_hydrant:ref']) name = `H ${tags['fire_hydrant:ref']}`;
            if (!tags.name && tags['ref']) name = `${isStation ? 'Wache' : 'H'} ${tags['ref']}`;

            let desc = [];
            for (const [k, v] of Object.entries(tags)) {
                desc.push(`${k}: ${v}`);
            }
            
            gpx += `  <wpt lat="${lat}" lon="${lon}">\n`;
            gpx += `    <name>${escapeXML(name)}</name>\n`;
            gpx += `    <desc>${escapeXML(desc.join('\n'))}</desc>\n`;
            gpx += `    <sym>${isStation ? 'Fire Station' : 'Hydrant'}</sym>\n`;
            gpx += `  </wpt>\n`;
        });

        gpx += '</gpx>';

        // Datei zum Download anbieten
        const blob = new Blob([gpx], {type: 'application/gpx+xml'});
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.download = `OpenFireMap_Export_${new Date().toISOString().slice(0,10)}.gpx`;
        link.href = url;
        link.click();
        URL.revokeObjectURL(url);
        
        showNotification(`${pointsToExport.length} ${t('gpx_success')}`);
        toggleExportMenu();
    }

    // Hilft, Sonderzeichen sicher für XML zu machen
    function escapeXML(str) {
        return str.replace(/[<>&'"]/g, c => {
            switch (c) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                case '\'': return '&apos;';
                case '"': return '&quot;';
            }
        });
    }

    // PNG Export: Erstellt das große Bild
    async function exportAsPNG() {
        exportAbortController = new AbortController();
        const signal = exportAbortController.signal;
        
        document.getElementById('export-setup').classList.add('hidden');
        document.getElementById('export-progress').classList.remove('hidden');
        const progressBar = document.getElementById('progress-bar'), progressPercent = document.getElementById('progress-percent'), progressLabel = document.getElementById('progress-label');
        
        const targetZoom = exportZoomLevel;
        const fallbackZoom = targetZoom - 1; 
        const bounds = finalBounds || map.getBounds(); 
        const nw = bounds.getNorthWest(), se = bounds.getSouthEast();

        progressLabel.innerText = t('locating'); 
        
        let displayTitle = "OpenFireMap.org";
        const centerLat = bounds.getCenter().lat;
        const centerLon = bounds.getCenter().lng;

        // Versuche Ortsnamen zu finden
        try {
            const fetchAddress = async (lat, lon) => {
                const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18`); 
                const d = await res.json();
                const addr = d.address || {};
                const city = addr.city || addr.town || addr.village || addr.municipality || "";
                const suburb = addr.suburb || addr.neighbourhood || addr.hamlet || "";
                return { city, suburb };
            };

            const centerLoc = await fetchAddress(centerLat, centerLon);
            if (centerLoc.city) {
                displayTitle = centerLoc.suburb ? `${centerLoc.city} - ${centerLoc.suburb}` : centerLoc.city;
            }

            if (targetZoom === 14 || targetZoom === 15) {
                const pointsToCheck = [
                    {lat: nw.lat, lon: nw.lng}, {lat: nw.lat, lon: se.lng}, 
                    {lat: se.lat, lon: se.lng}, {lat: se.lat, lon: nw.lng}  
                ];
                const promises = pointsToCheck.map(p => fetchAddress(p.lat, p.lon));
                const results = await Promise.all(promises);
                results.push(centerLoc);
                const uniqueCities = new Set();
                results.forEach(loc => { if (loc.city) uniqueCities.add(loc.city); });
                if (uniqueCities.size >= 3) displayTitle = "OpenFireMap.org";
            }
        } catch (e) { console.error("Titel Fehler:", e); }

        const worldSize = (z) => Math.pow(2, z);
        const lat2tile = (lat, z) => (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * worldSize(z);
        const lon2tile = (lon, z) => (lon + 180) / 360 * worldSize(z);
        
        const x1 = Math.floor(lon2tile(nw.lng, targetZoom));
        const y1 = Math.floor(lat2tile(nw.lat, targetZoom));
        const x2 = Math.floor(lon2tile(se.lng, targetZoom));
        const y2 = Math.floor(lat2tile(se.lat, targetZoom));

        const canvas = document.createElement('canvas');
        canvas.width = (x2 - x1 + 1) * 256; 
        canvas.height = (y2 - y1 + 1) * 256;
        
        if (canvas.width > 14000 || canvas.height > 14000) { 
            showNotification(t('too_large')); toggleExportMenu(); return; 
        }

        const ctx = canvas.getContext('2d');
        const totalTiles = (x2 - x1 + 1) * (y2 - y1 + 1);
        let loaded = 0;
        const baseUrlTpl = layerUrls[activeLayerConfig].replace('{s}', 'a').replace('{r}', '');

        progressLabel.innerText = `${t('loading_tiles')} (Z${targetZoom})...`;
        
        const tileQueue = [];
        for (let x = x1; x <= x2; x++) {
            for (let y = y1; y <= y2; y++) {
                tileQueue.push({x, y});
            }
        }

        const CONCURRENCY = 8; 
        const processQueue = async () => {
            while (tileQueue.length > 0 && !signal.aborted) {
                const {x, y} = tileQueue.shift();
                await new Promise(resolve => {
                    const img = new Image(); img.crossOrigin = "anonymous";
                    const zTargetUrl = baseUrlTpl.replace('{z}', targetZoom).replace('{x}', x).replace('{y}', y);
                    img.onload = () => { ctx.drawImage(img, (x - x1) * 256, (y - y1) * 256); loaded++; updateProgress(); resolve(); };
                    img.onerror = () => {
                        const zFallback_x = Math.floor(x/2); const zFallback_y = Math.floor(y/2);
                        const off_x = (x % 2) * 128; const off_y = (y % 2) * 128;
                        const zFallbackUrl = baseUrlTpl.replace('{z}', fallbackZoom).replace('{x}', zFallback_x).replace('{y}', zFallback_y);
                        const fImg = new Image(); fImg.crossOrigin = "anonymous"; fImg.src = zFallbackUrl;
                        fImg.onload = () => { ctx.drawImage(fImg, off_x, off_y, 128, 128, (x - x1) * 256, (y - y1) * 256, 256, 256); loaded++; updateProgress(); resolve(); };
                        fImg.onerror = () => { loaded++; resolve(); };
                    };
                    img.src = zTargetUrl;
                });
            }
        };

        const workers = [];
        for (let i = 0; i < CONCURRENCY; i++) workers.push(processQueue());
        await Promise.all(workers);

        function updateProgress() { const p = Math.round((loaded / totalTiles) * 80); progressBar.style.width = p + "%"; progressPercent.innerText = p + "%"; }
        if(signal.aborted) { toggleExportMenu(); return; }
        
        progressLabel.innerText = t('render_bounds');
        ctx.save(); ctx.translate(-x1 * 256, -y1 * 256); 
        ctx.strokeStyle = "#333333"; ctx.lineWidth = 2; ctx.setLineDash([20, 20]); ctx.lineCap = "round";

        for (let el of cachedElements) {
            if (el.tags && el.tags.boundary === 'administrative' && el.geometry) {
                if (targetZoom < 14) continue; 
                ctx.beginPath();
                let first = true;
                for (let p of el.geometry) {
                    const px = lon2tile(p.lon, targetZoom) * 256;
                    const py = lat2tile(p.lat, targetZoom) * 256;
                    if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
                }
                ctx.stroke();
            }
        }
        ctx.restore();

        progressLabel.innerText = t('render_infra');
        ctx.save(); ctx.translate(-x1 * 256, -y1 * 256);
        const iconCache = {};
        const renderedExportLocations = []; 

        for (let el of cachedElements) {
            const tags = el.tags || {};
            if (tags.boundary === 'administrative') continue;

            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            const isStation = tags.amenity === 'fire_station' || tags.building === 'fire_station';
            
            if (isStation) {
                const alreadyDrawn = renderedExportLocations.some(loc => Math.abs(loc.lat - lat) < 0.0001 && Math.abs(loc.lon - lon) < 0.0001);
                if (alreadyDrawn) continue;
                renderedExportLocations.push({lat, lon});
            }

            const type = isStation ? 'station' : (tags.emergency === 'defibrillator' ? 'defibrillator' : (tags['fire_hydrant:type'] || tags.emergency));
            const tx = lon2tile(lon, targetZoom) * 256;
            const ty = lat2tile(lat, targetZoom) * 256;
            
            if (tx < x1*256 || tx > (x2+1)*256 || ty < y1*256 || ty > (y2+1)*256) continue;

            if (isStation && targetZoom < 12) continue;
            if (type === 'defibrillator') {
                if (targetZoom < 16) continue;
            } else if (!isStation && targetZoom < 15) continue;

            const drawAsStationSquare = isStation && targetZoom < 14;
            const drawAsHydrantDot = !isStation && type !== 'defibrillator' && targetZoom < 17;
            const drawAsDefibDot = type === 'defibrillator' && targetZoom === 16;

            if (drawAsHydrantDot || drawAsStationSquare || drawAsDefibDot) {
                const isWater = ['water_tank', 'cistern', 'fire_water_pond', 'suction_point'].includes(type);
                const color = isStation ? '#ef4444' : (type === 'defibrillator' ? '#16a34a' : (isWater ? '#3b82f6' : '#ef4444'));
                ctx.beginPath();
                if (drawAsStationSquare) ctx.rect(tx - 5, ty - 5, 10, 10); else ctx.arc(tx, ty, 5, 0, 2 * Math.PI);
                ctx.fillStyle = color; ctx.fill(); ctx.lineWidth = 1.5; ctx.strokeStyle = "white"; ctx.stroke();
            } else {
                if (!iconCache[type]) {
                    const svgB = new Blob([getSVGContent(type)], {type: 'image/svg+xml;charset=utf-8'}), url = URL.createObjectURL(svgB), img = new Image();
                    img.src = url; await new Promise(res => img.onload = res); iconCache[type] = img;
                }
                ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 8; ctx.shadowOffsetY = 4;
                const iconScale = targetZoom < 17 ? 0.8 : 1.0; 
                const size = (type === 'station' ? 38 : 34) * iconScale;
                ctx.drawImage(iconCache[type], tx - size/2, ty - size/2, size, size);
                ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
            }
        }
        ctx.restore();

        progressLabel.innerText = t('layout_final');
        const bannerH = 150; 
        ctx.fillStyle = "rgba(255, 255, 255, 0.98)"; ctx.fillRect(0, 0, canvas.width, bannerH);
        ctx.strokeStyle = "rgba(15, 23, 42, 0.2)"; ctx.lineWidth = 3; ctx.strokeRect(0, 0, canvas.width, bannerH);
        
        ctx.fillStyle = "#0f172a"; ctx.textAlign = "center";
        const finalTitle = displayTitle === "OpenFireMap.org" ? "OpenFireMap.org" : `${t('plan_title')} ${displayTitle}`;
        ctx.font = "bold 44px Arial, sans-serif"; ctx.fillText(finalTitle, canvas.width / 2, 60);
        
        const now = new Date();
        const mPerPx = (Math.cos(bounds.getCenter().lat * Math.PI / 180) * 2 * Math.PI * 6378137) / (256 * Math.pow(2, targetZoom));
        ctx.font = "24px Arial, sans-serif"; ctx.fillStyle = "#334155";
        
        // Datum passend zur Sprache formatieren
        const localeMap = {
            'de': 'de-DE', 'en': 'en-US', 'fr': 'fr-FR', 'es': 'es-ES', 
            'it': 'it-IT', 'pl': 'pl-PL', 'nl': 'nl-NL', 'cs': 'cs-CZ'
        };
        const dateLocale = localeMap[currentLang] || 'en-US';
        const dateStr = now.toLocaleDateString(dateLocale, { year: 'numeric', month: 'long' });
        
        ctx.fillText(`${t('legend_date')}: ${dateStr} | ${t('legend_res')}: Z${targetZoom} (~${mPerPx.toFixed(2)} m/px)`, canvas.width / 2, 105);

        const prettyD = [1000, 500, 250, 100, 50]; 
        let distM = 100, scaleW = 100 / mPerPx;
        for (let d of prettyD) { let w = d / mPerPx; if (w <= canvas.width * 0.3) { distM = d; scaleW = w; break; } }
        
        const sX = canvas.width - scaleW - 40, sY = canvas.height - 40;
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)"; ctx.fillRect(sX - 10, sY - 50, scaleW + 20, 60);
        ctx.strokeStyle = "#0f172a"; ctx.lineWidth = 3; 
        ctx.beginPath(); ctx.moveTo(sX, sY - 10); ctx.lineTo(sX, sY); ctx.lineTo(sX + scaleW, sY); ctx.lineTo(sX + scaleW, sY - 10); ctx.stroke();
        ctx.fillStyle = "#0f172a"; ctx.font = "bold 18px Arial"; ctx.fillText(`${distM} m`, sX + scaleW / 2, sY - 15);

        progressBar.style.width = "100%";
        const link = document.createElement('a'); 
        link.download = `Hydrantenplan_${finalTitle.replace(/[\s\.]/g, '_')}_Z${targetZoom}_${activeLayerConfig}_${now.toISOString().slice(0,10)}.png`;
        link.href = canvas.toDataURL("image/png"); 
        link.click();
        Object.values(iconCache).forEach(img => URL.revokeObjectURL(img.src)); 
        setTimeout(toggleExportMenu, 800);
    }

    // Beim Starten der Seite: initMap ausführen
    window.onload = initMap;
</script>
</body>
