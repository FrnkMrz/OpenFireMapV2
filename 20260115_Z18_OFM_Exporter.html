<!-- 
    PROJEKT: OpenFireMap V2 - High-Res Exporter & GPX Tool
    
    HINWEIS FÜR EINSTEIGER:
    Dieser Code ist eine "Single Page Application" (SPA). Das bedeutet, die gesamte 
    Anwendung läuft in einer einzigen Datei im Browser. Es ist kein separater Server-Code nötig.
    
    STRUKTUR DIESER DATEI:
    1. HTML (Zeile ~60): Das Gerüst der Seite (Was ist zu sehen?).
    2. CSS (Zeile ~20): Das Design (Farben, Positionen, Schatten).
    3. JavaScript (Zeile ~260): Die Intelligenz (Daten laden, Karte malen, Exportieren).

    NEUHEITEN & LOGIK:
    - Smart Loading: Lädt Daten erst, wenn man nah genug heranzoomt.
    - GPX Export: Erlaubt das Speichern der Hydranten für Navigationsgeräte.
    - PNG Export: Erzeugt riesige Bilder zum Ausdrucken.

    AUTOR: Gemini (im Auftrag von Frank März)
    DATUM: 2026-01-16
-->
<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <!-- Wichtig für Handys: Damit die Seite nicht winzig klein herausgezoomt startet -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenFireMap.org V2</title>
    
    <!-- 
        EXTERNE BIBLIOTHEKEN (Unsere Werkzeugkiste)
        Wir laden hier fertigen Code von anderen Servern (CDNs), damit wir das Rad nicht neu erfinden müssen.
        - Leaflet: Der Weltmarktführer für Open-Source Landkarten im Web.
        - Tailwind CSS: Ein Design-System, das uns hilft, Dinge schnell hübsch zu machen (z.B. 'bg-blue-500').
    -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- CSS (Cascading Style Sheets) - Hier bestimmen wir das Aussehen -->
    <style>
        /* Grundeinstellungen für die ganze Seite */
        body { 
            margin: 0; padding: 0; 
            overflow: hidden; /* Verhindert Scrollbalken am Rand - die Karte soll Vollbild sein */
            font-family: sans-serif; 
            background: #0f172a; /* Dunkelblauer Hintergrund (angenehm für die Augen) */
        }
        
        /* Der Container, in den Leaflet später die Karte "malen" wird */
        #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #1e293b; }
        
        /* "Glassmorphism" Design für die Menüs:
           Das sind die halbtransparenten Boxen. 
           backdrop-filter: blur(12px) sorgt für den modernen Milchglas-Effekt.
        */
        .glass-panel { 
            background: rgba(15, 23, 42, 0.85); 
            backdrop-filter: blur(12px); 
            border: 1px solid rgba(255, 255, 255, 0.1); 
        }
        
        /* Styling für die Icons auf der Karte (Container) */
        .icon-container { 
            display: flex; align-items: center; justify-content: center; 
            filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4)); /* Kleiner Schatten für 3D-Effekt */
            transition: transform 0.1s ease; /* Weiche Animation beim Vergrößern */
        }
        /* Wenn man mit der Maus drüber fährt (hover), wird das Icon größer */
        .icon-container:hover { transform: scale(1.15); z-index: 1000 !important; }

        /* Kleine Punkte für niedrige Zoomstufen (weniger Details, damit die Karte nicht verstopft) */
        .hydrant-dot { background-color: #ef4444; border: 1.5px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        .tank-dot { background-color: #3b82f6; border: 1.5px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        /* Kleines Quadrat für Feuerwachen beim Rauszoomen */
        .station-square { background-color: #ef4444; border: 1px solid white; width: 10px; height: 10px; box-shadow: 0 0 4px rgba(0,0,0,0.5); }

        /* Anpassung der Popups (Tooltips), die erscheinen, wenn man über einen Marker fährt */
        .leaflet-tooltip { 
            background: #0f172a; 
            color: white; 
            border: 1px solid rgba(255,255,255,0.15); 
            border-radius: 8px; 
            font-size: 12px; 
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6); 
            padding: 0; 
        }

        /* Das Label "100m", das am Radius-Kreis steht */
        .range-label {
            background: transparent !important;
            border: none !important;
            box-shadow: none !important;
            color: #333333 !important;
            font-weight: bold;
            font-size: 14px;
            /* Ein weißer Rand um den Text (Text-Shadow Trick), damit man ihn auf jedem Hintergrund lesen kann */
            text-shadow: -1px -1px 0 rgba(255,255,255,0.8), 1px -1px 0 rgba(255,255,255,0.8), -1px 1px 0 rgba(255,255,255,0.8), 1px 1px 0 rgba(255,255,255,0.8);
        }
        
        .layer-btn.active { color: #3b82f6; background: rgba(59, 130, 246, 0.1); font-weight: bold; }
        
        /* Animation für den Export-Text (Pulsieren in Rot) */
        @keyframes pulse-red { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .exporting-active { animation: pulse-red 2s infinite; }

        #notification-box { 
            position: absolute; top: 20px; right: 20px; z-index: 2000; display: none;
            background: #ef4444; color: white; padding: 12px 24px; border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3); font-weight: 600;
        }

        .selection-mode { cursor: crosshair !important; } /* Fadenkreuz-Mauszeiger beim Auswählen */
        .zoom-btn:disabled { opacity: 0.3; cursor: not-allowed; border-color: transparent; }
    </style>
</head>
<body>

<!-- HTML STRUKTUR -->

<!-- Hier wird die Karte von Leaflet "rein gemalt". Es ist erst mal nur ein leerer Platzhalter. -->
<div id="map"></div>
<!-- Box für Fehlermeldungen oben rechts (z.B. "Keine Hydranten gefunden") -->
<div id="notification-box"></div>

<!-- 
    STEUERLEISTE (Oben Links)
    Hier sind die Buttons für Suche, GPS, Layer und Export.
    absolute top-5 left-5: Fixiert das Element 5 Einheiten vom oberen und linken Rand.
-->
<div class="absolute top-5 left-5 z-[1000] flex gap-3">
    <!-- Suchleiste -->
    <div class="flex glass-panel rounded-2xl shadow-2xl p-1 border border-white/5">
        <input type="text" id="search-input" placeholder="Ort suchen..." class="bg-transparent px-4 py-2 text-sm text-white outline-none w-48 focus:w-72 transition-all duration-500 placeholder:text-slate-500">
        <button onclick="searchLocation()" class="p-2 text-slate-400 hover:text-white transition-colors">
            <!-- Das <svg> ist das Lupen-Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
        </button>
    </div>
    
    <!-- GPS Button (Fadenkreuz Icon) -->
    <button onclick="locateUser()" id="locate-btn" class="glass-panel p-3 rounded-2xl text-slate-400 hover:text-emerald-400 shadow-2xl transition-all border border-white/10 active:scale-95" title="Mein Standort">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
        </svg>
    </button>
    
    <!-- Layer Button (Kartenstapel Icon) -->
    <button onclick="toggleLayerMenu()" class="glass-panel p-3 rounded-2xl text-slate-400 hover:text-white shadow-2xl transition-all border border-white/10 active:scale-95" title="Karte wechseln">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
        </svg>
    </button>

    <!-- Export Button (Drucker/Download Icon) -->
    <button onclick="toggleExportMenu()" class="glass-panel p-3 rounded-2xl text-blue-400 hover:text-blue-300 shadow-2xl transition-all border border-blue-500/20 active:scale-95" title="Export">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
        </svg>
    </button>
</div>

<!-- LAYER MENU (Versteckt: class="hidden") -->
<div id="layer-menu" class="hidden absolute top-20 left-28 z-[1001] w-64 glass-panel rounded-2xl p-4 shadow-2xl text-white border border-white/10">
    <h3 class="text-xs font-bold uppercase tracking-wider text-slate-500 mb-3 text-center">Hintergrund</h3>
    <div class="grid grid-cols-1 gap-1">
        <!-- Jeder Button ruft 'setBaseLayer' mit einem anderen Namen auf, um die Karte zu ändern -->
        <button onclick="setBaseLayer('voyager')" id="btn-voyager" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-blue-500"></div> Standard (Voyager)
        </button>
        <button onclick="setBaseLayer('positron')" id="btn-positron" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-slate-300"></div> Druck (Hell)
        </button>
        <button onclick="setBaseLayer('dark')" id="btn-dark" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-slate-800"></div> Nacht (Dunkel)
        </button>
        <button onclick="setBaseLayer('satellite')" id="btn-satellite" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-green-600"></div> Satellit (Esri)
        </button>
        <button onclick="setBaseLayer('topo')" id="btn-topo" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-amber-600"></div> Topographisch (OSM)
        </button>
        <button onclick="setBaseLayer('osm')" id="btn-osm" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2 border-t border-white/5 mt-1 pt-2">
            <div class="w-3 h-3 rounded-full bg-emerald-500"></div> OSM (Intl)
        </button>
        <button onclick="setBaseLayer('osmde')" id="btn-osmde" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-emerald-700"></div> OSM (DE Style)
        </button>
    </div>
</div>

<!-- EXPORT MENU (Das große Menü für PNG und GPX) -->
<div id="export-menu" class="hidden absolute top-20 left-5 z-[1001] w-80 glass-panel rounded-3xl p-6 shadow-2xl text-white border border-white/10">
    
    <!-- Ansicht 1: Einstellungen -->
    <div id="export-setup" class="space-y-5">
        <div class="flex justify-between items-center">
            <h3 class="font-bold text-lg">Export-Eigenschaften</h3>
            <button onclick="toggleExportMenu()" class="text-slate-500 hover:text-white">&times;</button>
        </div>
        
        <!-- Format Auswahl für PNG -->
        <div class="space-y-2">
            <label class="text-[10px] uppercase font-bold text-slate-500 tracking-wider">Format-Vorlage (Verhältnis)</label>
            <div class="grid grid-cols-3 gap-2">
                <button onclick="setExportFormat('free')" id="fmt-free" class="fmt-btn bg-white/10 p-2 rounded-xl text-[10px] font-bold border border-blue-400/50 text-blue-400 active">FREI</button>
                <button onclick="setExportFormat('a4l')" id="fmt-a4l" class="fmt-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10">DIN QUER</button>
                <button onclick="setExportFormat('a4p')" id="fmt-a4p" class="fmt-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10">DIN HOCH</button>
            </div>
        </div>

        <!-- Zoom Level Auswahl für PNG -->
        <div class="space-y-2">
            <label class="text-[10px] uppercase font-bold text-slate-500 tracking-wider">Detail-Grad (Zoom)</label>
            <div class="grid grid-cols-4 gap-2">
                <button onclick="setExportZoom(15)" id="zoom-15" class="zoom-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10">Z15</button>
                <button onclick="setExportZoom(16)" id="zoom-16" class="zoom-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10">Z16</button>
                <button onclick="setExportZoom(17)" id="zoom-17" class="zoom-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10">Z17</button>
                <button onclick="setExportZoom(18)" id="zoom-18" class="zoom-btn bg-white/10 p-2 rounded-xl text-[10px] font-bold border border-blue-400/50 text-blue-400 active">Z18</button>
            </div>
        </div>

        <!-- Button zum Rechteck ziehen -->
        <button onclick="startSelection()" id="select-btn" class="w-full bg-slate-800 hover:bg-slate-700 py-3 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 border border-white/10">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122" /></svg>
            Ausschnitt auf Karte wählen
        </button>

        <!-- Feedback wenn Auswahl getätigt wurde -->
        <div id="selection-info" class="hidden text-[11px] text-emerald-400 bg-emerald-400/10 p-2 rounded-lg text-center border border-emerald-400/20">
            Ausschnitt fixiert ✓
        </div>

        <!-- PNG Export Button (Blau) -->
        <button id="png-btn" onclick="exportAsPNG()" class="w-full bg-blue-600 hover:bg-blue-500 disabled:opacity-30 disabled:cursor-not-allowed py-3 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 shadow-lg">
            Hydrantenplan (PNG)
        </button>

        <!-- GPX Export Button (Grün) - NEU -->
        <button id="gpx-btn" onclick="exportAsGPX()" class="w-full bg-emerald-600 hover:bg-emerald-500 py-3 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 shadow-lg border border-emerald-400/30">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" /><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
            Hydranten exportieren (GPX)
        </button>
    </div>
    
    <!-- Ansicht 2: Ladebalken (wird nur angezeigt während des PNG-Exports) -->
    <div id="export-progress" class="hidden">
        <div class="flex justify-between items-center mb-4">
            <h3 class="font-bold text-lg exporting-active text-blue-400">Export wird erstellt...</h3>
        </div>
        <div class="space-y-4">
            <div>
                <div class="flex justify-between text-[10px] mb-1 uppercase tracking-widest text-blue-400 font-bold">
                    <span id="progress-label">Lade Kacheln...</span>
                    <span id="progress-percent">0%</span>
                </div>
                <!-- Der Hintergrundbalken -->
                <div class="h-2 w-full bg-slate-800 rounded-full overflow-hidden">
                    <!-- Der eigentliche Balken, der wächst -->
                    <div id="progress-bar" class="h-full bg-blue-500 w-0 transition-all duration-300"></div>
                </div>
            </div>
            <button onclick="cancelExport()" class="w-full bg-red-500/10 hover:bg-red-500/20 text-red-400 py-2 rounded-xl text-sm font-semibold border border-red-500/20">
                Vorgang abbrechen
            </button>
        </div>
    </div>
</div>

<!-- INFO BOX (Unten Rechts) - Zeigt aktuellen Zoom & Datenstatus -->
<div class="absolute bottom-10 right-10 z-[1000] glass-panel p-4 rounded-2xl text-[10px] text-slate-400 font-mono border border-white/5">
    <div class="flex justify-between gap-4"><span>ZOOM</span><span id="zoom-val" class="text-white font-bold">14.0</span></div>
    <div class="flex justify-between gap-4"><span>DATEN</span><span id="data-status" class="text-green-400">AKTUELL</span></div>
</div>

<!-- JAVASCRIPT LOGIK -->
<script>
    /* =========================================================================
       1. HAUPT-VARIABLEN (Unser "Gedächtnis")
       ========================================================================= */
    let map;                    // Die Variable für die Karte selbst
    let markerLayer;            // Eine transparente Folie für Hydranten und Wachen (Punkte)
    let boundaryLayer;          // Eine transparente Folie für Gemeindegrenzen (Linien)
    let rangeLayerGroup;        // Eine transparente Folie für den 100m Kreis
    let activeRangeCenter = null; // Speichert, welcher Hydrant gerade angeklickt ist
    
    // "Controller" zum Abbrechen von Netzwerk-Anfragen.
    // Wenn man wild zoomt, brechen wir alte, noch laufende Ladevorgänge ab, um nicht zu stauen.
    let currentRequestController; 
    let exportAbortController;
    
    let cachedElements = [];    // WICHTIG: Hier speichern wir alle Hydranten, die wir heruntergeladen haben.
    let activeLayerConfig = 'voyager'; // Welcher Kartenstil ist gerade aktiv?
    let exportFormat = 'free';  // 'free' (frei), 'a4l' (A4 Quer), 'a4p' (A4 Hoch)
    let exportZoomLevel = 18;   // Wie detailliert soll der PNG-Export sein?
    
    // Variablen für das Auswahl-Werkzeug (Rechteck ziehen)
    let isSelecting = false;
    let selectionRect = null;
    let startPoint = null;
    let finalBounds = null; // Das fertig gezogene Rechteck

    // Adressen der Karten-Server (Woher kommen die Hintergrund-Bilder?)
    // {z} = Zoomlevel, {x}/{y} = Koordinaten der Kachel
    const layerUrls = {
        voyager: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
        positron: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
        dark: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
        satellite: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        topo: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
        osm: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        osmde: 'https://{s}.tile.openstreetmap.de/{z}/{x}/{y}.png'
    };

    // Maximale Zoomstufen pro Karte (Manche Server haben keine ultra-detaillierten Bilder)
    const layerMaxZoom = { voyager: 18, positron: 18, dark: 18, satellite: 18, topo: 16, osm: 18, osmde: 18 };
    
    // Server für die Hydranten-Daten (Overpass API). Wir haben einen Backup-Server, falls der erste streikt.
    const overpassEndpoints = ['https://overpass-api.de/api/interpreter', 'https://overpass.kumi.systems/api/interpreter'];

    /* =========================================================================
       2. UI HELFER & KARTEN START
       ========================================================================= */
    
    // Zeigt die rote Nachricht oben rechts an ("Standort gefunden", "Fehler" etc.)
    function showNotification(msg) {
        const box = document.getElementById('notification-box');
        if (!box) return;
        box.innerText = msg;
        box.style.display = 'block';
        setTimeout(() => box.style.display = 'none', 3000); // Verschwindet nach 3 Sekunden automatisch
    }

    // Die Start-Funktion: Wird ausgeführt, sobald die Seite geladen ist (window.onload am Ende)
    function initMap() {
        // Wir erstellen die Gruppen-Layer (wie Overhead-Folien)
        markerLayer = L.layerGroup();
        boundaryLayer = L.layerGroup(); 
        rangeLayerGroup = L.layerGroup(); 
        
        // Erstelle die Karte im HTML-Element 'map', starte bei Schnaittach (Koordinaten), Zoom 14
        map = L.map('map', { zoomControl: false, center: [49.555, 11.350], zoom: 14 });
        
        setBaseLayer('voyager'); // Setze den Standard-Hintergrund
        
        // Füge die Folien zur Karte hinzu
        boundaryLayer.addTo(map); 
        rangeLayerGroup.addTo(map); 
        markerLayer.addTo(map);   
        
        // Event Listener: "Hör zu", was auf der Karte passiert
        map.on('moveend zoomend', fetchOSMData); // Wenn Karte bewegt -> Neue Daten laden
        map.on('zoomend', updateRangeCircle);    // Wenn Zoom geändert -> Radius prüfen (an/aus)
        map.on('zoom', () => document.getElementById('zoom-val').innerText = map.getZoom().toFixed(1)); // Anzeige updaten
        
        // Maus-Events für das Auswahl-Rechteck
        map.on('mousedown', onMouseDown);
        map.on('mousemove', onMouseMove);
        map.on('mouseup', onMouseUp);
        
        // Wenn man ins Leere klickt, soll der Radius-Kreis verschwinden
        map.on('click', () => {
            if (activeRangeCenter && !isSelecting) {
                activeRangeCenter = null;
                updateRangeCircle();
            }
        });

        // Lade sofort Daten beim Start
        fetchOSMData();
    }

    /* =========================================================================
       3. DATEN LADEN (Die "Intelligenz" der App)
       ========================================================================= */
    
    // Hilfsfunktion: Versucht Server 1, wenn kaputt, dann Server 2
    async function fetchWithRetry(query) {
        for (let endpoint of overpassEndpoints) {
            try {
                // Sende Anfrage an Server
                const res = await fetch(`${endpoint}?data=${encodeURIComponent(query)}`, { signal: currentRequestController.signal });
                if (!res.ok) continue; // Wenn Fehler, nächster Server probieren
                const text = await res.text();
                // Check ob Antwort Müll ist (z.B. HTML Fehlerseite statt JSON Daten)
                if (text.trim().startsWith('<?xml') || text.trim().startsWith('<html')) continue;
                return JSON.parse(text); // Wandle Text in nutzbare JSON-Daten um
            } catch (e) { if (e.name === 'AbortError') throw e; } // Wenn wir selbst abgebrochen haben, Fehler werfen
        }
        throw new Error("API Fehler - Keine Verbindung zu Overpass");
    }

    // Hauptfunktion: Entscheidet, was geladen wird
    async function fetchOSMData() {
        const zoom = map.getZoom();
        
        // --- OPTIMIERUNG: ZOOM FILTER ---
        // Wenn wir zu weit weg sind (Zoom < 12), laden wir NICHTS.
        // Das spart Datenvolumen, da man Hydranten aus dem Weltraum eh nicht sieht.
        if (zoom < 12) {
            document.getElementById('data-status').innerText = "STANDBY (Zoom < 12)";
            cachedElements = [];
            markerLayer.clearLayers();
            boundaryLayer.clearLayers();
            return; // Abbruch der Funktion, wir machen hier nichts mehr
        }
        
        // Berechne die Koordinaten des sichtbaren Bereichs (Bounding Box)
        const b = map.getBounds();
        const bbox = `${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()}`;
        
        const status = document.getElementById('data-status');
        status.innerText = "LÄDT...";
        
        // Breche alte laufende Anfragen ab (wenn User schnell scrollt)
        if (currentRequestController) currentRequestController.abort();
        currentRequestController = new AbortController();
        
        // Wir bauen den Text für die Datenbank-Abfrage dynamisch zusammen
        let queryParts = [];
        
        // STUFE 1: FEUERWEHRHÄUSER (Ab Zoom 12)
        // Wachen sind wichtig, die zeigen wir schon früh an.
        if (zoom >= 12) {
            queryParts.push(`nwr["amenity"="fire_station"](${bbox});`);
            queryParts.push(`nwr["building"="fire_station"](${bbox});`);
        }

        // STUFE 2: HYDRANTEN (Ab Zoom 15)
        // Hydranten gibt es tausende. Die laden wir erst, wenn man nah dran ist (Zoom 15).
        // Das verhindert, dass das Handy bei Zoom 13 abstürzt, weil es 50.000 Hydranten laden will.
        if (zoom >= 15) {
            queryParts.push(`nwr["emergency"~"fire_hydrant|water_tank|suction_point|fire_water_pond|cistern"](${bbox});`);
        }

        // STUFE 3: GRENZEN (Ab Zoom 14)
        let boundaryQuery = '';
        if (zoom >= 14) {
            boundaryQuery = `(way["boundary"="administrative"]["admin_level"="8"](${bbox});)->.boundaries; .boundaries out geom;`;
        }

        if (queryParts.length === 0 && boundaryQuery === '') return;

        // Der finale Code für die Overpass API (sieht kryptisch aus, ist aber Standard)
        let q = `[out:json][timeout:90];
        (
          ${queryParts.join('\n')}
        )->.pois;
        .pois out center;
        ${boundaryQuery}`;
        
        try {
            // Warten auf Antwort (await)...
            const data = await fetchWithRetry(q);
            cachedElements = data.elements; // Daten im "Gedächtnis" speichern für später (GPX/PNG)
            renderMarkers(data.elements, zoom); // Marker auf Karte malen
            status.innerText = "AKTUELL";
        } catch (e) { if (e.name !== 'AbortError') status.innerText = "FEHLER"; }
    }

    /* =========================================================================
       4. DARSTELLUNG (Icons & Marker)
       ========================================================================= */
    
    // Erzeugt den SVG-Code (das Bild) für das Icon
    function getSVGContent(type) {
        const isWater = ['water_tank', 'cistern', 'fire_water_pond', 'suction_point'].includes(type);
        const color = isWater ? '#3b82f6' : '#ef4444'; // Blau für Saugstellen, Rot für Hydranten
        
        // Spezialfall: Wandhydrant (Quadrat-Symbol)
        if (type === 'wall') {
             return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <circle cx="50" cy="50" r="45" fill="${color}" stroke="white" stroke-width="5"/>
                <circle cx="42" cy="52" r="18" fill="none" stroke="white" stroke-width="6" />
                <line x1="64" y1="34" x2="64" y2="70" stroke="white" stroke-width="6" stroke-linecap="round" />
            </svg>`;
        }
        
        // Buchstaben im Kreis (U = Unterflur, O = Oberflur)
        let char = '';
        switch(type) {
            case 'underground': char = 'U'; break; 
            case 'pillar':      char = 'O'; break; 
            case 'pipe':        char = 'I'; break;
            case 'dry_barrel':  char = 'Ø'; break; 
            default:            char = '';
        }

        // Feuerwehrhaus Icon
        if (type === 'station') return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M10 40 L50 5 L90 40 L90 90 L10 90 Z" fill="#ef4444" stroke="white" stroke-width="4"/><rect x="30" y="55" width="40" height="35" rx="2" fill="white" opacity="0.9"/></svg>`;
        
        // Standard Hydrant Icon (Kreis mit Buchstabe)
        return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="45" fill="${color}" stroke="white" stroke-width="5"/>${char ? `<text x="50" y="72" font-family="Arial" font-weight="bold" font-size="50" text-anchor="middle" fill="white">${char}</text>` : ''}</svg>`;
    }

    // Diese Funktion malt die Marker auf die Karte
    function renderMarkers(elements, zoom) {
        markerLayer.clearLayers(); // Erstmal alles alte löschen
        boundaryLayer.clearLayers(); 
        const renderedLocations = []; // Liste um Doppelte zu vermeiden
        
        elements.forEach(el => {
            const tags = el.tags || {};
            
            // --- GRENZEN (Linien) ---
            if (tags.boundary === 'administrative' && el.geometry) {
                if (zoom < 14) return; // Unter Zoom 14 keine Grenzen malen
                const latlngs = el.geometry.map(p => [p.lat, p.lon]);
                L.polyline(latlngs, {
                    color: '#333333', weight: 1, dashArray: '10, 10', opacity: 0.7
                }).addTo(boundaryLayer);
                return; 
            }

            // Koordinaten holen
            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            if (!lat || !lon) return;

            const isStation = tags.amenity === 'fire_station' || tags.building === 'fire_station';
            const type = isStation ? 'station' : (tags['fire_hydrant:type'] || tags.emergency);

            // Sicherheits-Check: Falls alte Daten im Cache sind, aber wir rausgezoomt haben
            if (isStation && zoom < 12) return; 
            if (!isStation && zoom < 15) return; 

            // Verhindern, dass Marker genau übereinander gemalt werden
            const alreadyDrawn = renderedLocations.some(loc => 
                Math.abs(loc.lat - lat) < 0.0001 && Math.abs(loc.lon - lon) < 0.0001
            );
            if (isStation && alreadyDrawn) return;
            if (isStation) renderedLocations.push({lat, lon});

            // --- DARSTELLUNG LOGIK ---
            if (isStation) {
                if (zoom < 14) {
                     // Zoom 12-13: Wache ist nur ein kleines Quadrat
                     L.marker([lat, lon], { icon: L.divIcon({ html: '<div class="station-square"></div>', iconSize: [10,10] }) }).addTo(markerLayer);
                } else {
                     // Ab Zoom 14: Wache ist ein richtiges Icon
                     const iconHtml = getSVGContent(type);
                     const marker = L.marker([lat, lon], { 
                        icon: L.divIcon({ className: 'icon-container', html: iconHtml, iconSize: [32, 32] }), 
                        zIndexOffset: 1000 // Wachen liegen immer oben auf
                    }).addTo(markerLayer);
                    
                    if (zoom === 18) {
                        marker.bindTooltip(generateTooltip(tags), { sticky: true, opacity: 0.95 });
                    }
                }
            } else {
                // Hydranten
                if (zoom < 17) {
                    // Zoom 15-16: Hydrant ist nur ein kleiner Punkt (Dot)
                    const color = ['water_tank', 'cistern', 'fire_water_pond', 'suction_point'].includes(type) ? 'tank-dot' : 'hydrant-dot';
                    L.marker([lat, lon], { icon: L.divIcon({ className: color, iconSize: [10,10] }) }).addTo(markerLayer);
                } else {
                    // Ab Zoom 17: Hydrant ist ein Icon (U/O)
                    const iconHtml = getSVGContent(type);
                    const marker = L.marker([lat, lon], { 
                        icon: L.divIcon({ className: 'icon-container', html: iconHtml, iconSize: [28, 28] }), 
                        zIndexOffset: 0 
                    }).addTo(markerLayer);
                    
                    if (zoom === 18) {
                        marker.bindTooltip(generateTooltip(tags), { sticky: true, opacity: 0.95 });
                    }

                    // Klick-Event für den 100m Kreis
                    marker.on('click', (e) => {
                        L.DomEvent.stopPropagation(e); // Verhindert, dass der Klick auf die Karte durchgeht
                        showRangeCircle(lat, lon);
                    });
                }
            }
        });
    }

    // Baut den HTML-Text für das Popup (Name, Details)
    function generateTooltip(tags) {
        const tooltipTitle = tags.name || "Details";
        let html = `<div class="p-2 min-w-[180px]">
            <div class="font-bold text-sm border-b border-white/20 pb-1 mb-1 text-blue-400">${tooltipTitle}</div>
            <div class="text-[10px] font-mono grid grid-cols-[auto_1fr] gap-x-2 gap-y-1">`;
        for (const [key, val] of Object.entries(tags)) {
            html += `<div class="text-slate-400 text-right">${key}:</div><div class="text-slate-200 break-words">${val}</div>`;
        }
        html += `</div></div>`;
        return html;
    }

    // Zeigt den orangenen 100m Kreis an
    function showRangeCircle(lat, lon) {
        activeRangeCenter = {lat, lon};
        updateRangeCircle();
    }

    function updateRangeCircle() {
        rangeLayerGroup.clearLayers();
        if (!activeRangeCenter) return;
        const zoom = map.getZoom();
        if (zoom < 16) return; 

        L.circle([activeRangeCenter.lat, activeRangeCenter.lon], {
            color: '#f97316', fillColor: '#f97316', fillOpacity: 0.15, radius: 100, weight: 2, dashArray: '5, 8', interactive: false 
        }).addTo(rangeLayerGroup);

        if (zoom >= 17) {
            // Mathe für das Label: Wo ist 50m rechts vom Zentrum?
            const latRad = activeRangeCenter.lat * Math.PI / 180;
            const kmPerDegLon = 111.32 * Math.cos(latRad);
            const offsetLon = 0.05 / kmPerDegLon; 
            const labelPos = [activeRangeCenter.lat, activeRangeCenter.lon + offsetLon];
            const labelMarker = L.marker(labelPos, {opacity: 0, interactive: false}).addTo(rangeLayerGroup);
            labelMarker.bindTooltip("100 m", { permanent: true, direction: 'center', className: 'range-label', offset: [0, 0] }).openTooltip();
        }
    }

    // Geolocation API: Fragt den Browser nach GPS Position
    function locateUser() {
        if (!navigator.geolocation) { showNotification("Geolokalisierung nicht unterstützt."); return; }
        const btn = document.getElementById('locate-btn');
        const icon = btn ? btn.querySelector('svg') : null;
        if(icon) icon.classList.add('animate-spin'); 

        navigator.geolocation.getCurrentPosition(
            (pos) => {
                const { latitude, longitude } = pos.coords;
                map.flyTo([latitude, longitude], 18, { animate: true, duration: 1.5 });
                if(icon) icon.classList.remove('animate-spin');
                showNotification("Standort gefunden!");
            },
            (err) => {
                console.warn("Geolocation Fehler:", err);
                if(icon) icon.classList.remove('animate-spin');
                showNotification("Standort fehlerhaft.");
            },
            { enableHighAccuracy: true, timeout: 5000 }
        );
    }

    /* =========================================================================
       5. EXPORT & MENÜ FUNKTIONEN (UI Logik)
       ========================================================================= */
    function setExportFormat(fmt) {
        exportFormat = fmt;
        document.querySelectorAll('.fmt-btn').forEach(b => {
            b.classList.remove('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
            b.classList.add('bg-white/5');
        });
        document.getElementById(`fmt-${fmt}`).classList.add('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
        clearSelection(); 
    }

    function setExportZoom(z) {
        if (activeLayerConfig === 'topo' && z > 17) return; 
        exportZoomLevel = z;
        document.querySelectorAll('.zoom-btn').forEach(b => {
            b.classList.remove('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
            b.classList.add('bg-white/5');
        });
        const activeBtn = document.getElementById(`zoom-${z}`);
        if(activeBtn) {
            activeBtn.classList.add('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
            activeBtn.classList.remove('bg-white/5');
        }
    }

    function startSelection() {
        isSelecting = true;
        clearSelection();
        map.dragging.disable(); 
        map.getContainer().classList.add('selection-mode'); 
        showNotification("Bereich ziehen");
    }

    function clearSelection() {
        if (selectionRect) { map.removeLayer(selectionRect); selectionRect = null; }
        finalBounds = null;
        document.getElementById('selection-info').classList.add('hidden');
    }

    // Maus-Events für das Auswahl-Rechteck
    function onMouseDown(e) {
        if (!isSelecting) return;
        startPoint = e.latlng;
        selectionRect = L.rectangle([startPoint, startPoint], {
            color: '#3b82f6', weight: 2, fillOpacity: 0.2, interactive: false
        }).addTo(map);
    }

    function onMouseMove(e) {
        if (!isSelecting || !startPoint || !selectionRect) return;
        let current = e.latlng;
        // Erzwinge Seitenverhältnis wenn DIN Format gewählt ist
        if (exportFormat !== 'free') {
            const ratio = (exportFormat === 'a4l') ? 1.4142 : 0.7071; 
            const lngScale = Math.cos(startPoint.lat * Math.PI / 180);
            const dy = Math.abs(current.lat - startPoint.lat);
            const dx = (dy * ratio) / lngScale;
            const latDir = current.lat > startPoint.lat ? 1 : -1;
            const lngDir = current.lng > startPoint.lng ? 1 : -1;
            current = L.latLng(startPoint.lat + (latDir * dy), startPoint.lng + (lngDir * dx));
        }
        selectionRect.setBounds([startPoint, current]);
    }

    function onMouseUp(e) {
        if (!isSelecting || !startPoint) return;
        finalBounds = selectionRect.getBounds(); 
        isSelecting = false; startPoint = null;
        map.dragging.enable(); 
        map.getContainer().classList.remove('selection-mode');
        document.getElementById('selection-info').classList.remove('hidden');
    }

    function setBaseLayer(key) {
        activeLayerConfig = key;
        map.eachLayer(layer => { if (layer instanceof L.TileLayer) map.removeLayer(layer); });
        L.tileLayer(layerUrls[key], { attribution: '&copy; OSM', crossOrigin: 'anonymous' }).addTo(map);
        document.querySelectorAll('.layer-btn').forEach(btn => btn.classList.remove('active'));
        const activeBtn = document.getElementById(`btn-${key}`);
        if(activeBtn) activeBtn.classList.add('active');
        const btn18 = document.getElementById('zoom-18');
        if (key === 'topo') {
            btn18.disabled = true;
            if (exportZoomLevel > 17) setExportZoom(17);
        } else {
            btn18.disabled = false;
        }
    }

    function toggleExportMenu() { document.getElementById('export-menu').classList.toggle('hidden'); resetExportUI(); }
    function toggleLayerMenu() { document.getElementById('layer-menu').classList.toggle('hidden'); }
    function resetExportUI() {
        document.getElementById('export-setup').classList.remove('hidden');
        document.getElementById('export-progress').classList.add('hidden');
        document.getElementById('progress-bar').style.width = '0%';
    }
    function cancelExport() { if(exportAbortController) exportAbortController.abort(); }

    // Nominatim Suche
    function searchLocation() {
        const q = document.getElementById('search-input').value;
        if (!q) return;
        fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`).then(r => r.json()).then(d => { if(d.length) map.flyTo([d[0].lat, d[0].lon], 18); });
    }

    /* =========================================================================
       6. EXPORT FUNKTIONEN (GPX & PNG)
       Hier passiert die Magie für den Download.
       ========================================================================= */
    
    // --- GPX EXPORT (XML Datei für Navis) ---
    function exportAsGPX() {
        // 1. Welche Region? (Rechteck-Auswahl oder ganzer sichtbarer Bildschirm)
        const bounds = finalBounds || map.getBounds();

        // 2. Daten filtern
        // Wir gehen durch alle gespeicherten Hydranten (cachedElements) und prüfen:
        // "Liegt dieser Punkt innerhalb des gewählten Bereichs (bounds)?"
        const pointsToExport = cachedElements.filter(el => {
            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            if (!lat || !lon) return false;
            
            // Check: Ist der Punkt innerhalb der Auswahl?
            return bounds.contains(L.latLng(lat, lon));
        });

        if (pointsToExport.length === 0) {
            showNotification("Keine Objekte im gewählten Bereich!");
            return;
        }

        // 3. GPX Datei bauen (Text zusammenkleben)
        // GPX ist eigentlich nur Text im XML Format. Wir schreiben Zeile für Zeile.
        let gpx = '<?xml version="1.0" encoding="UTF-8"?>\n';
        gpx += '<gpx version="1.1" creator="OpenFireMap V2" xmlns="http://www.topografix.com/GPX/1/1">\n';
        gpx += `  <metadata><name>Hydranten Export</name><time>${new Date().toISOString()}</time></metadata>\n`;

        pointsToExport.forEach(el => {
            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            const tags = el.tags || {};
            
            // Nur Relevantes exportieren (Hydranten & Wachen) - keine Grenzen
            const isStation = tags.amenity === 'fire_station' || tags.building === 'fire_station';
            const isHydrant = tags.emergency && ['fire_hydrant', 'water_tank', 'suction_point', 'fire_water_pond', 'cistern'].some(t => tags.emergency.includes(t));

            if (!isStation && !isHydrant) return;

            // Name generieren: Navis zeigen oft nur den Namen an.
            // Wir versuchen "Ref-Nummer" zu nehmen, sonst "Name", sonst "Hydrant".
            let name = tags.name || (isStation ? "Feuerwache" : "Hydrant");
            if (!tags.name && tags['fire_hydrant:ref']) name = `H ${tags['fire_hydrant:ref']}`;
            if (!tags.name && tags['ref']) name = `${isStation ? 'Wache' : 'H'} ${tags['ref']}`;

            // Alle Details (Druck, Durchmesser etc.) in das Beschreibungs-Feld packen
            let desc = [];
            for (const [k, v] of Object.entries(tags)) {
                desc.push(`${k}: ${v}`);
            }
            
            // Wegpunkt schreiben (<wpt>)
            gpx += `  <wpt lat="${lat}" lon="${lon}">\n`;
            gpx += `    <name>${escapeXML(name)}</name>\n`; // escapeXML macht sicher, dass keine Sonderzeichen den Code kaputt machen
            gpx += `    <desc>${escapeXML(desc.join('\n'))}</desc>\n`;
            gpx += `    <sym>${isStation ? 'Fire Station' : 'Hydrant'}</sym>\n`;
            gpx += `  </wpt>\n`;
        });

        gpx += '</gpx>';

        // 4. Download starten
        // Wir erstellen ein "Blob" (Binary Large Object) - quasi eine virtuelle Datei im Speicher.
        const blob = new Blob([gpx], {type: 'application/gpx+xml'});
        const url = URL.createObjectURL(blob);
        
        // Wir erstellen einen unsichtbaren Link und klicken ihn automatisch an.
        const link = document.createElement('a');
        link.download = `OpenFireMap_Export_${new Date().toISOString().slice(0,10)}.gpx`;
        link.href = url;
        link.click();
        
        // Speicher freigeben
        URL.revokeObjectURL(url);
        
        showNotification(`${pointsToExport.length} Objekte als GPX exportiert!`);
        toggleExportMenu();
    }

    // Hilfsfunktion: Sonderzeichen (z.B. & < >) für XML sicher machen, damit die Datei valide bleibt
    function escapeXML(str) {
        return str.replace(/[<>&'"]/g, c => {
            switch (c) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                case '\'': return '&apos;';
                case '"': return '&quot;';
            }
        });
    }

    // --- PNG EXPORT (Bild erzeugen) ---
    async function exportAsPNG() {
        exportAbortController = new AbortController();
        const signal = exportAbortController.signal;
        
        document.getElementById('export-setup').classList.add('hidden');
        document.getElementById('export-progress').classList.remove('hidden');
        const progressBar = document.getElementById('progress-bar'), progressPercent = document.getElementById('progress-percent'), progressLabel = document.getElementById('progress-label');
        
        const targetZoom = exportZoomLevel;
        const fallbackZoom = targetZoom - 1; 
        const bounds = finalBounds || map.getBounds(); 
        const nw = bounds.getNorthWest(), se = bounds.getSouthEast();

        progressLabel.innerText = "Lokalisiere Gebiet...";
        
        // Titel finden (Reverse Geocoding)
        let displayTitle = "OpenFireMap.org";
        const centerLat = bounds.getCenter().lat;
        const centerLon = bounds.getCenter().lng;

        try {
            const fetchAddress = async (lat, lon) => {
                const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=18`); 
                const d = await res.json();
                const addr = d.address || {};
                const city = addr.city || addr.town || addr.village || addr.municipality || "";
                const suburb = addr.suburb || addr.neighbourhood || addr.hamlet || "";
                return { city, suburb };
            };

            const centerLoc = await fetchAddress(centerLat, centerLon);
            if (centerLoc.city) {
                displayTitle = centerLoc.suburb ? `${centerLoc.city} - ${centerLoc.suburb}` : centerLoc.city;
            }

            // Logik: Wenn zu viele verschiedene Orte im Bild sind, nehmen wir einen neutralen Titel
            if (targetZoom === 14 || targetZoom === 15) {
                const pointsToCheck = [
                    {lat: nw.lat, lon: nw.lng}, {lat: nw.lat, lon: se.lng}, 
                    {lat: se.lat, lon: se.lng}, {lat: se.lat, lon: nw.lng}  
                ];
                const promises = pointsToCheck.map(p => fetchAddress(p.lat, p.lon));
                const results = await Promise.all(promises);
                results.push(centerLoc);
                const uniqueCities = new Set();
                results.forEach(loc => { if (loc.city) uniqueCities.add(loc.city); });
                if (uniqueCities.size >= 3) displayTitle = "OpenFireMap.org";
            }
        } catch (e) { console.error("Titel Fehler:", e); }

        // Mathe für die Kacheln (Umrechnung Lat/Lon -> Kachel X/Y)
        const worldSize = (z) => Math.pow(2, z);
        const lat2tile = (lat, z) => (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * worldSize(z);
        const lon2tile = (lon, z) => (lon + 180) / 360 * worldSize(z);
        
        const x1 = Math.floor(lon2tile(nw.lng, targetZoom));
        const y1 = Math.floor(lat2tile(nw.lat, targetZoom));
        const x2 = Math.floor(lon2tile(se.lng, targetZoom));
        const y2 = Math.floor(lat2tile(se.lat, targetZoom));

        // Canvas (Leinwand) erstellen
        const canvas = document.createElement('canvas');
        canvas.width = (x2 - x1 + 1) * 256; 
        canvas.height = (y2 - y1 + 1) * 256;
        
        // Limit prüfen (Browser stürzen ab bei zu großen Bildern)
        if (canvas.width > 14000 || canvas.height > 14000) { 
            showNotification(`Ausschnitt zu groß!`); toggleExportMenu(); return; 
        }

        const ctx = canvas.getContext('2d');
        const totalTiles = (x2 - x1 + 1) * (y2 - y1 + 1);
        let loaded = 0;
        const baseUrlTpl = layerUrls[activeLayerConfig].replace('{s}', 'a').replace('{r}', '');

        progressLabel.innerText = `Sammle Kacheln (Z${targetZoom})...`;
        
        // Warteschlange für Bilder füllen
        const tileQueue = [];
        for (let x = x1; x <= x2; x++) {
            for (let y = y1; y <= y2; y++) {
                tileQueue.push({x, y});
            }
        }

        // Parallelisierung: 8 Bilder gleichzeitig laden
        const CONCURRENCY = 8; 
        const processQueue = async () => {
            while (tileQueue.length > 0 && !signal.aborted) {
                const {x, y} = tileQueue.shift();
                await new Promise(resolve => {
                    const img = new Image(); img.crossOrigin = "anonymous";
                    const zTargetUrl = baseUrlTpl.replace('{z}', targetZoom).replace('{x}', x).replace('{y}', y);
                    img.onload = () => { ctx.drawImage(img, (x - x1) * 256, (y - y1) * 256); loaded++; updateProgress(); resolve(); };
                    img.onerror = () => {
                        // Fallback: Wenn Kachel fehlt, nimm die unscharfe Version (Zoom - 1) und vergrößere sie
                        const zFallback_x = Math.floor(x/2); const zFallback_y = Math.floor(y/2);
                        const off_x = (x % 2) * 128; const off_y = (y % 2) * 128;
                        const zFallbackUrl = baseUrlTpl.replace('{z}', fallbackZoom).replace('{x}', zFallback_x).replace('{y}', zFallback_y);
                        const fImg = new Image(); fImg.crossOrigin = "anonymous"; fImg.src = zFallbackUrl;
                        fImg.onload = () => { ctx.drawImage(fImg, off_x, off_y, 128, 128, (x - x1) * 256, (y - y1) * 256, 256, 256); loaded++; updateProgress(); resolve(); };
                        fImg.onerror = () => { loaded++; resolve(); };
                    };
                    img.src = zTargetUrl;
                });
            }
        };

        const workers = [];
        for (let i = 0; i < CONCURRENCY; i++) workers.push(processQueue());
        await Promise.all(workers);

        function updateProgress() { const p = Math.round((loaded / totalTiles) * 80); progressBar.style.width = p + "%"; progressPercent.innerText = p + "%"; }
        if(signal.aborted) { toggleExportMenu(); return; }
        
        // Grenzen einzeichnen
        progressLabel.innerText = "Rendere Grenzen...";
        ctx.save(); ctx.translate(-x1 * 256, -y1 * 256); 
        ctx.strokeStyle = "#333333"; ctx.lineWidth = 2; ctx.setLineDash([20, 20]); ctx.lineCap = "round";

        for (let el of cachedElements) {
            if (el.tags && el.tags.boundary === 'administrative' && el.geometry) {
                if (targetZoom < 14) continue; 
                ctx.beginPath();
                let first = true;
                for (let p of el.geometry) {
                    const px = lon2tile(p.lon, targetZoom) * 256;
                    const py = lat2tile(p.lat, targetZoom) * 256;
                    if (first) { ctx.moveTo(px, py); first = false; } else { ctx.lineTo(px, py); }
                }
                ctx.stroke();
            }
        }
        ctx.restore();

        // Marker einzeichnen
        progressLabel.innerText = "Rendere Infrastruktur...";
        ctx.save(); ctx.translate(-x1 * 256, -y1 * 256);
        const iconCache = {};
        const renderedExportLocations = []; 

        for (let el of cachedElements) {
            const tags = el.tags || {};
            if (tags.boundary === 'administrative') continue;

            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            const isStation = tags.amenity === 'fire_station' || tags.building === 'fire_station';
            
            if (isStation) {
                const alreadyDrawn = renderedExportLocations.some(loc => Math.abs(loc.lat - lat) < 0.0001 && Math.abs(loc.lon - lon) < 0.0001);
                if (alreadyDrawn) continue;
                renderedExportLocations.push({lat, lon});
            }

            const type = isStation ? 'station' : (tags['fire_hydrant:type'] || tags.emergency);
            const tx = lon2tile(lon, targetZoom) * 256;
            const ty = lat2tile(lat, targetZoom) * 256;
            
            if (tx < x1*256 || tx > (x2+1)*256 || ty < y1*256 || ty > (y2+1)*256) continue;

            if (isStation && targetZoom < 12) continue;
            if (!isStation && targetZoom < 15) continue;

            const drawAsDot = !isStation && targetZoom < 17;
            const drawAsStationSquare = isStation && targetZoom < 14;

            if (drawAsDot || drawAsStationSquare) {
                const isWater = ['water_tank', 'cistern', 'fire_water_pond', 'suction_point'].includes(type);
                const color = isStation ? '#ef4444' : (isWater ? '#3b82f6' : '#ef4444');
                ctx.beginPath();
                if (drawAsStationSquare) ctx.rect(tx - 5, ty - 5, 10, 10); else ctx.arc(tx, ty, 5, 0, 2 * Math.PI);
                ctx.fillStyle = color; ctx.fill(); ctx.lineWidth = 1.5; ctx.strokeStyle = "white"; ctx.stroke();
            } else {
                if (!iconCache[type]) {
                    const svgB = new Blob([getSVGContent(type)], {type: 'image/svg+xml;charset=utf-8'}), url = URL.createObjectURL(svgB), img = new Image();
                    img.src = url; await new Promise(res => img.onload = res); iconCache[type] = img;
                }
                ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 8; ctx.shadowOffsetY = 4;
                const iconScale = targetZoom < 17 ? 0.8 : 1.0; 
                const size = (type === 'station' ? 38 : 34) * iconScale;
                ctx.drawImage(iconCache[type], tx - size/2, ty - size/2, size, size);
                ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
            }
        }
        ctx.restore();

        // Titel und Legende malen
        progressLabel.innerText = "Finalisiere Layout...";
        const bannerH = 150; 
        ctx.fillStyle = "rgba(255, 255, 255, 0.98)"; ctx.fillRect(0, 0, canvas.width, bannerH);
        ctx.strokeStyle = "rgba(15, 23, 42, 0.2)"; ctx.lineWidth = 3; ctx.strokeRect(0, 0, canvas.width, bannerH);
        
        ctx.fillStyle = "#0f172a"; ctx.textAlign = "center";
        const finalTitle = displayTitle === "OpenFireMap.org" ? "OpenFireMap.org" : `Orts- und Hydrantenplan ${displayTitle}`;
        ctx.font = "bold 44px Arial, sans-serif"; ctx.fillText(finalTitle, canvas.width / 2, 60);
        
        const now = new Date();
        const mPerPx = (Math.cos(bounds.getCenter().lat * Math.PI / 180) * 2 * Math.PI * 6378137) / (256 * Math.pow(2, targetZoom));
        ctx.font = "24px Arial, sans-serif"; ctx.fillStyle = "#334155";
        ctx.fillText(`Stand: ${now.toLocaleString('de-DE', { month: 'long', year: 'numeric' })} | Auflösung: Z${targetZoom} (~${mPerPx.toFixed(2)} m/px)`, canvas.width / 2, 105);

        const prettyD = [1000, 500, 250, 100, 50]; 
        let distM = 100, scaleW = 100 / mPerPx;
        for (let d of prettyD) { let w = d / mPerPx; if (w <= canvas.width * 0.3) { distM = d; scaleW = w; break; } }
        
        const sX = canvas.width - scaleW - 40, sY = canvas.height - 40;
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)"; ctx.fillRect(sX - 10, sY - 50, scaleW + 20, 60);
        ctx.strokeStyle = "#0f172a"; ctx.lineWidth = 3; 
        ctx.beginPath(); ctx.moveTo(sX, sY - 10); ctx.lineTo(sX, sY); ctx.lineTo(sX + scaleW, sY); ctx.lineTo(sX + scaleW, sY - 10); ctx.stroke();
        ctx.fillStyle = "#0f172a"; ctx.font = "bold 18px Arial"; ctx.fillText(`${distM} m`, sX + scaleW / 2, sY - 15);

        progressBar.style.width = "100%";
        const link = document.createElement('a'); 
        link.download = `Hydrantenplan_${finalTitle.replace(/[\s\.]/g, '_')}_Z${targetZoom}_${activeLayerConfig}_${now.toISOString().slice(0,10)}.png`;
        link.href = canvas.toDataURL("image/png"); 
        link.click();
        Object.values(iconCache).forEach(img => URL.revokeObjectURL(img.src)); 
        setTimeout(toggleExportMenu, 800);
    }

    // Beim Starten der Seite: initMap ausführen
    window.onload = initMap;
</script>
</body>
</html>
