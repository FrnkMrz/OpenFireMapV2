<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenFireMap V2 - Ausschnitt-Pro</title>
    <!-- Leaflet Bibliothek -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; padding: 0; overflow: hidden; font-family: sans-serif; background: #0f172a; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; background: #1e293b; }
        
        .glass-panel { background: rgba(15, 23, 42, 0.85); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); }
        
        .icon-container { display: flex; align-items: center; justify-content: center; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.4)); transition: transform 0.1s ease; }
        .icon-container:hover { transform: scale(1.15); z-index: 1000 !important; }

        .hydrant-dot { background-color: #ef4444; border: 1.5px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        .tank-dot { background-color: #3b82f6; border: 1.5px solid white; border-radius: 50%; width: 10px; height: 10px; box-shadow: 0 0 5px rgba(0,0,0,0.3); }
        /* Farbe auf #ef4444 geändert (gleiches Rot wie Hydranten) */
        .station-square { background-color: #ef4444; border: 1px solid white; width: 10px; height: 10px; box-shadow: 0 0 4px rgba(0,0,0,0.5); }

        /* Tooltip Style angepasst für Listen */
        .leaflet-tooltip { 
            background: #0f172a; 
            color: white; 
            border: 1px solid rgba(255,255,255,0.15); 
            border-radius: 8px; 
            font-size: 12px; 
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6); 
            padding: 0; /* Padding im HTML kontrolliert */
        }
        
        .layer-btn.active { color: #3b82f6; background: rgba(59, 130, 246, 0.1); font-weight: bold; }

        @keyframes pulse-red { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .exporting-active { animation: pulse-red 2s infinite; }

        #notification-box { 
            position: absolute; top: 20px; right: 20px; z-index: 2000; display: none;
            background: #ef4444; color: white; padding: 12px 24px; border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3); font-weight: 600;
        }

        .selection-mode { cursor: crosshair !important; }
    </style>
</head>
<body>

<div id="map"></div>
<div id="notification-box"></div>

<!-- Haupt-Navigation -->
<div class="absolute top-5 left-5 z-[1000] flex gap-3">
    <div class="flex glass-panel rounded-2xl shadow-2xl p-1 border border-white/5">
        <input type="text" id="search-input" placeholder="Ort suchen..." class="bg-transparent px-4 py-2 text-sm text-white outline-none w-48 focus:w-72 transition-all duration-500 placeholder:text-slate-500">
        <button onclick="searchLocation()" class="p-2 text-slate-400 hover:text-white transition-colors">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
        </button>
    </div>
    
    <button onclick="toggleLayerMenu()" class="glass-panel p-3 rounded-2xl text-slate-400 hover:text-white shadow-2xl transition-all border border-white/10 active:scale-95" title="Karte wechseln">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 20l-5.447-2.724A1 1 0 013 16.382V5.618a1 1 0 011.447-.894L9 7m0 13l6-3m-6 3V7m6 10l4.553 2.276A1 1 0 0021 18.382V7.618a1 1 0 00-.553-.894L15 4m0 13V4m0 0L9 7" />
        </svg>
    </button>

    <button onclick="toggleExportMenu()" class="glass-panel p-3 rounded-2xl text-blue-400 hover:text-blue-300 shadow-2xl transition-all border border-blue-500/20 active:scale-95" title="Export">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 00-2 2z" /></svg>
    </button>
</div>

<!-- Ebenen-Menü -->
<div id="layer-menu" class="hidden absolute top-20 left-28 z-[1001] w-64 glass-panel rounded-2xl p-4 shadow-2xl text-white border border-white/10">
    <h3 class="text-xs font-bold uppercase tracking-wider text-slate-500 mb-3 text-center">Hintergrund</h3>
    <div class="grid grid-cols-1 gap-1">
        <button onclick="setBaseLayer('voyager')" id="btn-voyager" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-blue-500"></div> Standard (Voyager)
        </button>
        <button onclick="setBaseLayer('positron')" id="btn-positron" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-slate-300"></div> Druck (Hell)
        </button>
        <button onclick="setBaseLayer('dark')" id="btn-dark" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-slate-800"></div> Nacht (Dunkel)
        </button>
        <button onclick="setBaseLayer('satellite')" id="btn-satellite" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-green-600"></div> Satellit (Esri)
        </button>
        <button onclick="setBaseLayer('topo')" id="btn-topo" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-amber-600"></div> Topographisch (OSM)
        </button>
        <button onclick="setBaseLayer('osm')" id="btn-osm" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2 border-t border-white/5 mt-1 pt-2">
            <div class="w-3 h-3 rounded-full bg-emerald-500"></div> OSM (Intl)
        </button>
        <button onclick="setBaseLayer('osmde')" id="btn-osmde" class="layer-btn w-full text-left px-3 py-2 rounded-xl text-sm transition-all hover:bg-white/5 flex items-center gap-2">
            <div class="w-3 h-3 rounded-full bg-emerald-700"></div> OSM (DE Style)
        </button>
    </div>
</div>

<!-- Export-Fenster -->
<div id="export-menu" class="hidden absolute top-20 left-5 z-[1001] w-80 glass-panel rounded-3xl p-6 shadow-2xl text-white border border-white/10">
    <div id="export-setup" class="space-y-5">
        <div class="flex justify-between items-center">
            <h3 class="font-bold text-lg">Export-Eigenschaften</h3>
            <button onclick="toggleExportMenu()" class="text-slate-500 hover:text-white">&times;</button>
        </div>
        
        <div class="space-y-2">
            <label class="text-[10px] uppercase font-bold text-slate-500 tracking-wider">Format-Vorlage (Verhältnis)</label>
            <div class="grid grid-cols-3 gap-2">
                <button onclick="setExportFormat('free')" id="fmt-free" class="fmt-btn bg-white/10 p-2 rounded-xl text-[10px] font-bold border border-blue-400/50 text-blue-400 active">FREI</button>
                <button onclick="setExportFormat('a4l')" id="fmt-a4l" class="fmt-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10">DIN QUER</button>
                <button onclick="setExportFormat('a4p')" id="fmt-a4p" class="fmt-btn bg-white/5 p-2 rounded-xl text-[10px] font-bold border border-white/10 hover:bg-white/10">DIN HOCH</button>
            </div>
        </div>

        <button onclick="startSelection()" id="select-btn" class="w-full bg-slate-800 hover:bg-slate-700 py-3 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 border border-white/10">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 15l-2 5L9 9l11 4-5 2zm0 0l5 5M7.188 2.239l.777 2.897M5.136 7.965l-2.898-.777M13.95 4.05l-2.122 2.122m-5.657 5.656l-2.12 2.122" /></svg>
            Ausschnitt auf Karte wählen
        </button>

        <div id="selection-info" class="hidden text-[11px] text-emerald-400 bg-emerald-400/10 p-2 rounded-lg text-center border border-emerald-400/20">
            Ausschnitt fixiert ✓
        </div>

        <button id="png-btn" onclick="exportAsPNG()" class="w-full bg-blue-600 hover:bg-blue-500 disabled:opacity-30 disabled:cursor-not-allowed py-3 rounded-xl font-semibold transition-colors flex items-center justify-center gap-2 shadow-lg">
            Hydrantenplan erzeugen
        </button>
    </div>
    
    <div id="export-progress" class="hidden">
        <div class="flex justify-between items-center mb-4">
            <h3 class="font-bold text-lg exporting-active text-blue-400">Export wird erstellt...</h3>
        </div>
        <div class="space-y-4">
            <div>
                <div class="flex justify-between text-[10px] mb-1 uppercase tracking-widest text-blue-400 font-bold">
                    <span id="progress-label">Lade Kacheln...</span>
                    <span id="progress-percent">0%</span>
                </div>
                <div class="h-2 w-full bg-slate-800 rounded-full overflow-hidden">
                    <div id="progress-bar" class="h-full bg-blue-500 w-0 transition-all duration-300"></div>
                </div>
            </div>
            <button onclick="cancelExport()" class="w-full bg-red-500/10 hover:bg-red-500/20 text-red-400 py-2 rounded-xl text-sm font-semibold border border-red-500/20">
                Vorgang abbrechen
            </button>
        </div>
    </div>
</div>

<div class="absolute bottom-10 right-10 z-[1000] glass-panel p-4 rounded-2xl text-[10px] text-slate-400 font-mono border border-white/5">
    <div class="flex justify-between gap-4"><span>ZOOM</span><span id="zoom-val" class="text-white font-bold">14.0</span></div>
    <div class="flex justify-between gap-4"><span>DATEN</span><span id="data-status" class="text-green-400">AKTUELL</span></div>
</div>

<script>
    let map, markerLayer, boundaryLayer, currentRequestController, exportAbortController;
    let cachedElements = [];
    let activeLayerConfig = 'voyager';
    let exportFormat = 'free'; 
    
    let isSelecting = false;
    let selectionRect = null;
    let startPoint = null;
    let finalBounds = null;

    const layerUrls = {
        voyager: 'https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png',
        positron: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
        dark: 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
        satellite: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
        topo: 'https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png',
        osm: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        osmde: 'https://{s}.tile.openstreetmap.de/{z}/{x}/{y}.png'
    };

    const layerMaxZoom = {
        voyager: 18, positron: 18, dark: 18, satellite: 18, topo: 16, osm: 18, osmde: 18
    };

    const overpassEndpoints = ['https://overpass-api.de/api/interpreter', 'https://overpass.kumi.systems/api/interpreter'];

    function showNotification(msg) {
        const box = document.getElementById('notification-box');
        box.innerText = msg;
        box.style.display = 'block';
        setTimeout(() => box.style.display = 'none', 3000);
    }

    function initMap() {
        markerLayer = L.layerGroup();
        boundaryLayer = L.layerGroup(); // Eigener Layer für Grenzen
        
        map = L.map('map', { zoomControl: false, center: [49.5605, 11.3411], zoom: 14 });
        setBaseLayer('voyager');
        
        // Reihenfolge wichtig: Grenzen unter Marker
        boundaryLayer.addTo(map);
        markerLayer.addTo(map);
        
        map.on('moveend zoomend', fetchOSMData);
        map.on('zoom', () => document.getElementById('zoom-val').innerText = map.getZoom().toFixed(1));
        
        map.on('mousedown', onMouseDown);
        map.on('mousemove', onMouseMove);
        map.on('mouseup', onMouseUp);

        fetchOSMData();
    }

    function setExportFormat(fmt) {
        exportFormat = fmt;
        document.querySelectorAll('.fmt-btn').forEach(b => {
            b.classList.remove('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
            b.classList.add('bg-white/5');
        });
        const activeBtn = document.getElementById(`fmt-${fmt}`);
        activeBtn.classList.add('active', 'text-blue-400', 'border-blue-400/50', 'bg-white/10');
        clearSelection();
    }

    function startSelection() {
        isSelecting = true;
        clearSelection();
        map.dragging.disable();
        map.getContainer().classList.add('selection-mode');
        showNotification("Klicken und ziehen, um Bereich zu wählen");
    }

    function clearSelection() {
        if (selectionRect) {
            map.removeLayer(selectionRect);
            selectionRect = null;
        }
        finalBounds = null;
        document.getElementById('selection-info').classList.add('hidden');
    }

    function onMouseDown(e) {
        if (!isSelecting) return;
        startPoint = e.latlng;
        selectionRect = L.rectangle([startPoint, startPoint], {
            color: '#3b82f6', weight: 2, fillOpacity: 0.2, interactive: false
        }).addTo(map);
    }

    function onMouseMove(e) {
        if (!isSelecting || !startPoint || !selectionRect) return;
        let current = e.latlng;
        
        if (exportFormat !== 'free') {
            const ratio = (exportFormat === 'a4l') ? 1.4142 : 0.7071;
            const lngScale = Math.cos(startPoint.lat * Math.PI / 180);
            const dy = Math.abs(current.lat - startPoint.lat);
            const dx = (dy * ratio) / lngScale;
            const latDir = current.lat > startPoint.lat ? 1 : -1;
            const lngDir = current.lng > startPoint.lng ? 1 : -1;
            current = L.latLng(startPoint.lat + (latDir * dy), startPoint.lng + (lngDir * dx));
        }
        selectionRect.setBounds([startPoint, current]);
    }

    function onMouseUp(e) {
        if (!isSelecting || !startPoint) return;
        finalBounds = selectionRect.getBounds();
        isSelecting = false;
        startPoint = null;
        map.dragging.enable();
        map.getContainer().classList.remove('selection-mode');
        document.getElementById('selection-info').classList.remove('hidden');
    }

    function setBaseLayer(key) {
        activeLayerConfig = key;
        map.eachLayer(layer => { if (layer instanceof L.TileLayer) map.removeLayer(layer); });
        L.tileLayer(layerUrls[key], { attribution: '&copy; OSM', crossOrigin: 'anonymous' }).addTo(map);
        document.querySelectorAll('.layer-btn').forEach(btn => btn.classList.remove('active'));
        const activeBtn = document.getElementById(`btn-${key}`);
        if(activeBtn) activeBtn.classList.add('active');
    }

    async function fetchWithRetry(query) {
        for (let endpoint of overpassEndpoints) {
            try {
                const res = await fetch(`${endpoint}?data=${encodeURIComponent(query)}`, { signal: currentRequestController.signal });
                if (!res.ok) continue;
                const text = await res.text();
                if (text.trim().startsWith('<?xml') || text.trim().startsWith('<html')) continue;
                return JSON.parse(text);
            } catch (e) { if (e.name === 'AbortError') throw e; }
        }
        throw new Error("API Fehler");
    }

    async function fetchOSMData() {
        const zoom = map.getZoom();
        const b = map.getBounds();
        const bbox = `${b.getSouth()},${b.getWest()},${b.getNorth()},${b.getEast()}`;
        if (zoom < 10) return;
        const status = document.getElementById('data-status');
        status.innerText = "LÄDT...";
        if (currentRequestController) currentRequestController.abort();
        currentRequestController = new AbortController();
        
        let q = `[out:json][timeout:90];
        (
          nwr["amenity"="fire_station"](${bbox});
          nwr["building"="fire_station"](${bbox});
          nwr["emergency"~"fire_hydrant|water_tank|suction_point|fire_water_pond|cistern"](${bbox});
        )->.pois;
        .pois out center;
        
        (
          way["boundary"="administrative"]["admin_level"="8"](${bbox});
        )->.boundaries;
        .boundaries out geom;`;
        
        try {
            const data = await fetchWithRetry(q);
            cachedElements = data.elements;
            renderMarkers(data.elements, zoom);
            status.innerText = "AKTUELL";
        } catch (e) { if (e.name !== 'AbortError') status.innerText = "FEHLER"; }
    }

    function getSVGContent(type) {
        const isWater = ['water_tank', 'cistern', 'fire_water_pond', 'suction_point'].includes(type);
        const color = isWater ? '#3b82f6' : '#ef4444';
        
        // --- Spezialfall Wandhydrant: OI Grafik ---
        if (type === 'wall') {
             return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <circle cx="50" cy="50" r="45" fill="${color}" stroke="white" stroke-width="5"/>
                <circle cx="42" cy="52" r="18" fill="none" stroke="white" stroke-width="6" />
                <line x1="64" y1="34" x2="64" y2="70" stroke="white" stroke-width="6" stroke-linecap="round" />
            </svg>`;
        }
        
        // --- Standard switch logic ---
        let char = '';
        switch(type) {
            case 'underground': char = 'U'; break;
            case 'pillar':      char = 'O'; break; // Zurück zum O
            case 'pipe':        char = 'S'; break; 
            case 'dry_barrel':  char = 'Ø'; break;
            default:            char = '';
        }

        // --- Station auch auf das neue Rot geändert ---
        if (type === 'station') return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><path d="M10 40 L50 5 L90 40 L90 90 L10 90 Z" fill="#ef4444" stroke="white" stroke-width="4"/><rect x="30" y="55" width="40" height="35" rx="2" fill="white" opacity="0.9"/></svg>`;
        return `<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><circle cx="50" cy="50" r="45" fill="${color}" stroke="white" stroke-width="5"/>${char ? `<text x="50" y="72" font-family="Arial" font-weight="bold" font-size="50" text-anchor="middle" fill="white">${char}</text>` : ''}</svg>`;
    }

    function renderMarkers(elements, zoom) {
        markerLayer.clearLayers();
        boundaryLayer.clearLayers(); 
        const renderedLocations = [];
        
        elements.forEach(el => {
            const tags = el.tags || {};
            
            // --- 1. Grenzen erst ab Zoom 14 und dünner ---
            if (tags.boundary === 'administrative' && el.geometry) {
                if (zoom < 14) return; // Zoom Check
                const latlngs = el.geometry.map(p => [p.lat, p.lon]);
                L.polyline(latlngs, {
                    color: '#333333',
                    weight: 1, // Dünnere Linie
                    dashArray: '10, 10',
                    opacity: 0.7
                }).addTo(boundaryLayer);
                return; 
            }

            // --- POI Setup ---
            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            if (!lat || !lon) return;

            const isStation = tags.amenity === 'fire_station' || tags.building === 'fire_station';
            const type = isStation ? 'station' : (tags['fire_hydrant:type'] || tags.emergency);

            // --- 2. Sichtbarkeits-Regeln (Zoom Levels) ---
            if (isStation && zoom < 12) return;
            if (!isStation && zoom < 15) return;


            // --- 3. Rendering Logic ---
            const alreadyDrawn = renderedLocations.some(loc => 
                Math.abs(loc.lat - lat) < 0.0001 && Math.abs(loc.lon - lon) < 0.0001
            );
            if (isStation && alreadyDrawn) return;
            if (isStation) renderedLocations.push({lat, lon});

            
            if (isStation) {
                if (zoom < 14) {
                     L.marker([lat, lon], { icon: L.divIcon({ html: '<div class="station-square"></div>', iconSize: [10,10] }) }).addTo(markerLayer);
                } else {
                     const iconHtml = getSVGContent(type);
                     const size = 32;
                     L.marker([lat, lon], { 
                        icon: L.divIcon({ className: 'icon-container', html: iconHtml, iconSize: [size, size] }), 
                        zIndexOffset: 1000 
                    }).addTo(markerLayer).bindTooltip(generateTooltip(tags), { sticky: true, opacity: 0.95 });
                }
            } else {
                if (zoom < 17) {
                    const color = ['water_tank', 'cistern', 'fire_water_pond', 'suction_point'].includes(type) ? 'tank-dot' : 'hydrant-dot';
                    L.marker([lat, lon], { icon: L.divIcon({ className: color, iconSize: [10,10] }) }).addTo(markerLayer);
                } else {
                    const iconHtml = getSVGContent(type);
                    const size = 28;
                    L.marker([lat, lon], { 
                        icon: L.divIcon({ className: 'icon-container', html: iconHtml, iconSize: [size, size] }), 
                        zIndexOffset: 0 
                    }).addTo(markerLayer).bindTooltip(generateTooltip(tags), { sticky: true, opacity: 0.95 });
                }
            }
        });
    }

    // Helper für Tooltip Generation (ausgelagert für Übersichtlichkeit)
    function generateTooltip(tags) {
        const tooltipTitle = tags.name || "Details";
        let html = `<div class="p-2 min-w-[180px]">
            <div class="font-bold text-sm border-b border-white/20 pb-1 mb-1 text-blue-400">${tooltipTitle}</div>
            <div class="text-[10px] font-mono grid grid-cols-[auto_1fr] gap-x-2 gap-y-1">`;
        for (const [key, val] of Object.entries(tags)) {
            html += `<div class="text-slate-400 text-right">${key}:</div><div class="text-slate-200 break-words">${val}</div>`;
        }
        html += `</div></div>`;
        return html;
    }

    function toggleExportMenu() { document.getElementById('export-menu').classList.toggle('hidden'); resetExportUI(); }
    function toggleLayerMenu() { document.getElementById('layer-menu').classList.toggle('hidden'); }
    function resetExportUI() {
        document.getElementById('export-setup').classList.remove('hidden');
        document.getElementById('export-progress').classList.add('hidden');
        document.getElementById('progress-bar').style.width = '0%';
    }
    function cancelExport() { if(exportAbortController) exportAbortController.abort(); }

    async function exportAsPNG() {
        exportAbortController = new AbortController();
        const signal = exportAbortController.signal;
        document.getElementById('export-setup').classList.add('hidden');
        document.getElementById('export-progress').classList.remove('hidden');
        const progressBar = document.getElementById('progress-bar'), progressPercent = document.getElementById('progress-percent'), progressLabel = document.getElementById('progress-label');
        
        const targetZoom = layerMaxZoom[activeLayerConfig] || 18;
        const fallbackZoom = targetZoom - 1;
        const bounds = finalBounds || map.getBounds();
        const nw = bounds.getNorthWest(), se = bounds.getSouthEast();

        progressLabel.innerText = "Lokalisiere Gebiet...";
        let cityName = "Unbekannt", suburbName = "";
        try {
            const locRes = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${bounds.getCenter().lat}&lon=${bounds.getCenter().lng}&zoom=18`);
            const locData = await locRes.json();
            cityName = locData.address.city || locData.address.town || locData.address.village || "Gebiet";
            suburbName = locData.address.suburb || locData.address.neighbourhood || "";
        } catch (e) {}

        const worldSize = (z) => Math.pow(2, z), lat2tile = (lat, z) => (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * worldSize(z), lon2tile = (lon, z) => (lon + 180) / 360 * worldSize(z);
        const x1 = Math.floor(lon2tile(nw.lng, targetZoom)), y1 = Math.floor(lat2tile(nw.lat, targetZoom)), x2 = Math.floor(lon2tile(se.lng, targetZoom)), y2 = Math.floor(lat2tile(se.lat, targetZoom));

        const canvas = document.createElement('canvas');
        canvas.width = (x2 - x1 + 1) * 256; canvas.height = (y2 - y1 + 1) * 256;
        if (canvas.width > 15000 || canvas.height > 15000) { showNotification("Ausschnitt zu groß!"); toggleExportMenu(); return; }

        const ctx = canvas.getContext('2d');
        const totalTiles = (x2 - x1 + 1) * (y2 - y1 + 1);
        let loaded = 0;
        const baseUrlTpl = layerUrls[activeLayerConfig].replace('{s}', 'a').replace('{r}', '');

        progressLabel.innerText = `Sammle Kacheln (Z${targetZoom})...`;
        for (let x = x1; x <= x2; x++) {
            for (let y = y1; y <= y2; y++) {
                if(signal.aborted) { toggleExportMenu(); return; }
                await new Promise(resolve => {
                    const img = new Image(); img.crossOrigin = "anonymous";
                    const zTargetUrl = baseUrlTpl.replace('{z}', targetZoom).replace('{x}', x).replace('{y}', y);
                    img.onload = () => { ctx.drawImage(img, (x - x1) * 256, (y - y1) * 256); loaded++; updateProgress(); resolve(); };
                    img.onerror = () => {
                        const zFallback_x = Math.floor(x/2), zFallback_y = Math.floor(y/2), off_x = (x % 2) * 128, off_y = (y % 2) * 128;
                        const zFallbackUrl = baseUrlTpl.replace('{z}', fallbackZoom).replace('{x}', zFallback_x).replace('{y}', zFallback_y);
                        const fImg = new Image(); fImg.crossOrigin = "anonymous"; fImg.src = zFallbackUrl;
                        fImg.onload = () => { ctx.drawImage(fImg, off_x, off_y, 128, 128, (x - x1) * 256, (y - y1) * 256, 256, 256); loaded++; updateProgress(); resolve(); };
                        fImg.onerror = () => { loaded++; resolve(); };
                    };
                    img.src = zTargetUrl;
                });
            }
        }

        function updateProgress() { const p = Math.round((loaded / totalTiles) * 80); progressBar.style.width = p + "%"; progressPercent.innerText = p + "%"; }

        if(signal.aborted) { toggleExportMenu(); return; }
        
        progressLabel.innerText = "Rendere Grenzen...";
        ctx.save();
        ctx.translate(-x1 * 256, -y1 * 256);
        
        ctx.strokeStyle = "#333333"; 
        ctx.lineWidth = 2; // Dünnere Linie auch im Export
        ctx.setLineDash([20, 20]); 
        ctx.lineCap = "round";

        for (let el of cachedElements) {
            if (el.tags && el.tags.boundary === 'administrative' && el.geometry) {
                ctx.beginPath();
                let first = true;
                for (let p of el.geometry) {
                    const px = lon2tile(p.lon, targetZoom) * 256;
                    const py = lat2tile(p.lat, targetZoom) * 256;
                    if (first) { ctx.moveTo(px, py); first = false; }
                    else { ctx.lineTo(px, py); }
                }
                ctx.stroke();
            }
        }
        ctx.restore();

        progressLabel.innerText = "Rendere Infrastruktur...";
        ctx.save(); ctx.translate(-x1 * 256, -y1 * 256);
        const iconCache = {};
        const renderedExportLocations = []; 

        for (let el of cachedElements) {
            const tags = el.tags || {};
            if (tags.boundary === 'administrative') continue;

            const lat = el.lat || el.center?.lat;
            const lon = el.lon || el.center?.lon;
            const isStation = tags.amenity === 'fire_station' || tags.building === 'fire_station';
            
            if (isStation) {
                const alreadyDrawn = renderedExportLocations.some(loc => 
                    Math.abs(loc.lat - lat) < 0.0001 && Math.abs(loc.lon - lon) < 0.0001
                );
                if (alreadyDrawn) continue;
                renderedExportLocations.push({lat, lon});
            }

            const type = isStation ? 'station' : (tags['fire_hydrant:type'] || tags.emergency);
            const tx = lon2tile(lon, targetZoom) * 256, ty = lat2tile(lat, targetZoom) * 256;
            if (tx < x1*256 || tx > (x2+1)*256 || ty < y1*256 || ty > (y2+1)*256) continue;

            if (!iconCache[type]) {
                const svgB = new Blob([getSVGContent(type)], {type: 'image/svg+xml;charset=utf-8'}), url = URL.createObjectURL(svgB), img = new Image();
                img.src = url; await new Promise(res => img.onload = res); iconCache[type] = img;
            }
            ctx.shadowColor = "rgba(0,0,0,0.5)"; ctx.shadowBlur = 8; ctx.shadowOffsetY = 4;
            const iconScale = targetZoom === 16 ? 0.8 : 1.0;
            const size = (type === 'station' ? 38 : 34) * iconScale;
            ctx.drawImage(iconCache[type], tx - size/2, ty - size/2, size, size);
            ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
        }
        ctx.restore();

        progressLabel.innerText = "Finalisiere Layout...";
        const bannerH = 150; ctx.fillStyle = "rgba(255, 255, 255, 0.98)"; ctx.fillRect(0, 0, canvas.width, bannerH);
        ctx.strokeStyle = "rgba(15, 23, 42, 0.2)"; ctx.lineWidth = 3; ctx.strokeRect(0, 0, canvas.width, bannerH);
        ctx.fillStyle = "#0f172a"; ctx.textAlign = "center";
        const displayT = suburbName ? `${cityName} - ${suburbName}` : cityName;
        ctx.font = "bold 44px Arial, sans-serif"; ctx.fillText(`Orts- und Hydrantenplan ${displayT}`, canvas.width / 2, 60);
        const now = new Date();
        const mPerPx = (Math.cos(bounds.getCenter().lat * Math.PI / 180) * 2 * Math.PI * 6378137) / (256 * Math.pow(2, targetZoom));
        ctx.font = "24px Arial, sans-serif"; ctx.fillStyle = "#334155";
        ctx.fillText(`Stand: ${now.toLocaleString('de-DE', { month: 'long', year: 'numeric' })} | Auflösung: Z${targetZoom} (~${mPerPx.toFixed(2)} m/px)`, canvas.width / 2, 105);

        const prettyD = [1000, 500, 250, 100, 50]; let distM = 100, scaleW = 100 / mPerPx;
        for (let d of prettyD) { let w = d / mPerPx; if (w <= canvas.width * 0.3) { distM = d; scaleW = w; break; } }
        const sX = canvas.width - scaleW - 40, sY = canvas.height - 40;
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)"; ctx.fillRect(sX - 10, sY - 50, scaleW + 20, 60);
        ctx.strokeStyle = "#0f172a"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(sX, sY - 10); ctx.lineTo(sX, sY); ctx.lineTo(sX + scaleW, sY); ctx.lineTo(sX + scaleW, sY - 10); ctx.stroke();
        ctx.fillStyle = "#0f172a"; ctx.font = "bold 18px Arial"; ctx.fillText(`${distM} m`, sX + scaleW / 2, sY - 15);

        progressBar.style.width = "100%";
        const link = document.createElement('a'); link.download = `Hydrantenplan_${displayT.replace(/\s/g, '_')}_${now.toISOString().slice(0,10)}.png`; link.href = canvas.toDataURL("image/png"); link.click();
        Object.values(iconCache).forEach(img => URL.revokeObjectURL(img.src)); setTimeout(toggleExportMenu, 800);
    }

    function searchLocation() {
        const q = document.getElementById('search-input').value;
        if (!q) return;
        fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}`).then(r => r.json()).then(d => { if(d.length) map.flyTo([d[0].lat, d[0].lon], 18); });
    }

    function toggleExportMenu() { document.getElementById('export-menu').classList.toggle('hidden'); resetExportUI(); }
    function toggleLayerMenu() { document.getElementById('layer-menu').classList.toggle('hidden'); }
    window.onload = initMap;
</script>
</body>
</html>
